<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mrqyTalk</title>
  
  
  <link href="https://mrqytalk.github.io/atom.xml" rel="self"/>
  
  <link href="https://mrqytalk.github.io/"/>
  <updated>2022-04-18T08:07:00.668Z</updated>
  <id>https://mrqytalk.github.io/</id>
  
  <author>
    <name>吴同学</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySql逻辑架构</title>
    <link href="https://mrqytalk.github.io/2022/04/18/MySql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
    <id>https://mrqytalk.github.io/2022/04/18/MySql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</id>
    <published>2022-04-18T08:01:36.000Z</published>
    <updated>2022-04-18T08:07:00.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Mysql逻辑架构剖析"><a href="#1-Mysql逻辑架构剖析" class="headerlink" title="1. Mysql逻辑架构剖析"></a>1. Mysql逻辑架构剖析</h2><p><strong>1.1</strong> <strong>服务器处理客户端请求</strong></p><p>以查询请求为案例，服务端对客户端的请求处理如下：</p><img src="https://cdn.jsdelivr.net/gh/mrqyTalk/mrqyTalk.github.io@master/image/image-20220418085533068.png" alt="image-20220418085533068" style="zoom: 80%;" /><h3 id="1-2-第一层：连接层"><a href="#1-2-第一层：连接层" class="headerlink" title="1.2 第一层：连接层"></a>1.2 第一层：连接层</h3><p>系统（客户端）访问 <code>MySQL </code>服务器前，做的第一件事就是建立<code> TCP</code> 连接。</p><p>经过三次握手建立连接成功后， <code>MySQL </code>服务器对 <code> TCP</code> 传输过来的账号密码做身份认证、权限获取。</p><ul><li><p><strong>用户名或密码不对，会收到一个<code>Access denied for user</code>错误，客户端程序结束执行</strong></p></li><li><p><strong>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong></p></li></ul><p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><h3 id="1-3-第2层：服务层"><a href="#1-3-第2层：服务层" class="headerlink" title="1.3 第2层：服务层"></a><strong>1.3</strong> 第2层：服务层</h3><ul><li><p><strong>SQL Interface: SQL接口</strong></p><ul><li><p>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface </p></li><li><p>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</p></li></ul></li><li><p><strong>Parser:</strong> <strong>解析器</strong></p><ul><li><p>在解析器中对 SQL 语句进行<strong>语法分析、语义分析</strong>。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</p><blockquote><p>词法分析：你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>语法分析：语法分析器（比如：Bison）会根据语法规则，判断你输</p><p>入的这个 SQL 语句是否 满足 MySQL 语法 。</p></blockquote></li><li><p>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树 ，并根据数据字典丰富查询语法树，会<strong>验证该客户端是否具有执行该查询的权限</strong> 。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。</p></li></ul></li><li><p><strong>Optimizer:</strong> <strong>查询优化器</strong></p><ul><li><p>SQL语句在语法<strong>解析之后、查询之前</strong>会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划 。</p></li><li><p>这个执行计划表明应该<code>使用哪些索引</code>进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p></li><li><p>它使用<code>选取-投影-连接</code>策略进行查询。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where gender =&#x27;女&#x27;</span><br></pre></td></tr></table></figure><p>这个SELECT查询先根据WHERE语句进行<code>选取</code> ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性<code>投影</code> ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 <code>连接</code>起来生成最终查询结果。</p></li></ul></li><li><p><strong>Caches &amp; Buffers： 查询缓存组件</strong></p><ul><li><p>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</p></li><li><p>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</p></li><li><p>这个查询缓存可以在<code>不同客户端之间共享 </code>。 </p></li><li><p>从<code>MySQL 5.7.20</code>开始，不推荐使用查询缓存，并在 <code>MySQL 8.0</code>中删除 。</p></li></ul></li></ul><h3 id="1-4-第3层：引擎层"><a href="#1-4-第3层：引擎层" class="headerlink" title="1.4 第3层：引擎层"></a>1.4 第3层：引擎层</h3><p>插件式存储引擎层（Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p><p>MySQL8默认支持以下的存储引擎如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mrqyTalk/mrqyTalk.github.io@master/image/image-20220418104305891.png" alt="image-20220418104305891"></p><h3 id="1-5-存储层"><a href="#1-5-存储层" class="headerlink" title="1.5 存储层"></a>1.5 存储层</h3><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。</p><h2 id="2-数据库缓冲池（buffer-pool）"><a href="#2-数据库缓冲池（buffer-pool）" class="headerlink" title="2. 数据库缓冲池（buffer pool）"></a>2. 数据库缓冲池（buffer pool）</h2><p><code>InnoDB</code> 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 <code>I/O </code>需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请<code>占用内存来作为数据缓冲池 </code>，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。</p><p>这样做的好处是可以让磁盘活动最小化，从而<code>减少与磁盘直接进行 I/O 的时间 </code>。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果<strong>索引的数据在缓冲池里，那么访问的成本就会降低很多。</strong></p><h3 id="2-1-缓冲池VS查询缓存"><a href="#2-1-缓冲池VS查询缓存" class="headerlink" title="2.1 缓冲池VS查询缓存"></a>2.1 缓冲池VS查询缓存</h3><p><strong>缓冲池：</strong>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，包括：数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p><p><strong>查询缓存</strong>：是提前把查询结果缓存 起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是<strong>查询对应的结果。</strong>因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p><h3 id="2-2-缓冲池如何读取数据"><a href="#2-2-缓冲池如何读取数据" class="headerlink" title="2.2 缓冲池如何读取数据"></a>2.2 缓冲池如何读取数据</h3><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><h3 id="2-3-查看-x2F-设置缓冲池的大小"><a href="#2-3-查看-x2F-设置缓冲池的大小" class="headerlink" title="2.3 查看&#x2F;设置缓冲池的大小"></a>2.3 查看&#x2F;设置缓冲池的大小</h3><p>查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>缓冲池的value值以bit为单位</p></blockquote><p>修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global innodb_buffer_pool_size = 268435456;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Mysql逻辑架构剖析&quot;&gt;&lt;a href=&quot;#1-Mysql逻辑架构剖析&quot; class=&quot;headerlink&quot; title=&quot;1. Mysql逻辑架构剖析&quot;&gt;&lt;/a&gt;1. Mysql逻辑架构剖析&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.1&lt;/strong&gt; &lt;st</summary>
      
    
    
    
    <category term="数据库" scheme="https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://mrqytalk.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="https://mrqytalk.github.io/2022/04/17/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>https://mrqytalk.github.io/2022/04/17/mysql%E7%B4%A2%E5%BC%95/</id>
    <published>2022-04-17T03:57:26.000Z</published>
    <updated>2022-04-17T04:04:21.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Mysql索引简介"><a href="#1-Mysql索引简介" class="headerlink" title="1. Mysql索引简介"></a>1. Mysql索引简介</h2><h3 id="1-1-索引概念"><a href="#1-1-索引概念" class="headerlink" title="1.1 索引概念"></a>1.1 索引概念</h3><p>索引是一个<strong>单独的、存储在磁盘上的、排好序</strong>数据库结构，它们包含着对数据表里所有记录的引用指针。使用索引的功能在于快速找出在某个或多个列中有一特定值的行。</p><h3 id="1-2-索引的分类"><a href="#1-2-索引的分类" class="headerlink" title="1.2 索引的分类"></a>1.2 索引的分类</h3><p>按数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引</strong><br>按物理存储分类可分为：<strong>聚簇索引、二级索引</strong><br>按字段特性分类可分为：<strong>主键索引、普通索引、前缀索引</strong><br>按字段个数分类可分为：<strong>单列索引、联合索引</strong></p><blockquote><p>注：MySQL的索引类型由存储引擎决定，Mysql5.1之前的默认引擎是MyISAM，之后版本是InnoDB。而InnoDB你支持hash索引，但<strong>自适应</strong>Hash索引，即：InnoDB中Hash索引的创建由存储引擎引擎自动优化创建，不能人为干预是否为表创建Hash索引。<strong>因为hash索引只能精确匹配（如select * from user where <code>name</code> &#x3D; xx），不支持范围查找。</strong></p></blockquote><h2 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+树"></a>2. B+树</h2><h3 id="2-1-B-树的特点"><a href="#2-1-B-树的特点" class="headerlink" title="2.1 B+树的特点"></a>2.1 B+树的特点</h3><ul><li><p>在 B+ 树中，<strong>所有数据记录节点都是按照键值的大小存放在同一层的叶子节点上，而非叶子结点只存储key的信息，</strong>这样可以大大减少每个节点的存储的key的数量，降低B+ 树的高度</p></li><li><p>B+ 树叶子节点的关键字从小到大有序排列，<strong>左边结尾数据都会保存右边节点开始数据的指针。</strong></p></li><li><p>B+ 树的层级更少：相较于 B 树， B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快</p></li><li><p>B+ 树查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p></li><li><p>B+ 树天然具备排序功能：<strong>B+ 树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</strong></p></li><li><p>B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p></li></ul><h3 id="2-2-B-树的结构图"><a href="#2-2-B-树的结构图" class="headerlink" title="2.2 B+树的结构图"></a>2.2 B+树的结构图</h3><p><img src="https://cdn.jsdelivr.net/gh/mrqytalk/mrqytalk.github.io@master/image/image-20220417092116463.png" alt="image-20220417092116463"></p><p>Mysql存储的时候以<strong>数据页</strong>为最小单位，数据页与数据页之间通过<strong>双向链表</strong>关联，数据与数据页之间通过<strong>单项链表</strong>关联。</p><p>数据页中的数据是按照主键排序（没有主键是由 MySQL自己维护的 ROW_ID 来排序的），每一个数据页中的页号和最小主键构成<strong>主键目录</strong>。</p><p><strong>索引页+数据页</strong>组成的组成的B+树就是<strong>聚簇索引</strong>。聚簇索引是 MySQL 基于主键索引结构创建的。</p><p>模拟 MySQL 的查找过程，首先从<strong>最顶层的索引页</strong>开始查找，查找 id&#x3D;37，因此定位到了索引页16，然后到索引页 16 中继续查找，此时同样能够定位到 id&#x3D;37 在索引页 3 中，然后继续查找，最终能够定位到数据实在数据页 8 中，加入数据页中8的结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mrqytalk/mrqytalk.github.io@master/image/image-20220417100149016.png" alt="image-20220417100149016"></p><p>完整的数据表：</p><p><img src="https://cdn.jsdelivr.net/gh/mrqytalk/mrqytalk.github.io@master/image/image-20220417100006747.png" alt="image-20220417100006747"></p><h2 id="3-非主键索引"><a href="#3-非主键索引" class="headerlink" title="3. 非主键索引"></a>3. 非主键索引</h2><p>假如现在对<code>name+age(非主键)</code>建立索引，那此时是存放的呢？此时 MySQL 根据会 name+age 维护一个单独的 B+ 树结构，数据依旧是存放在数据页中的，只不过是原来数据中的每条记录写的是 id&#x3D;xx，现在写的是name&#x3D;xx，age&#x3D;xx，id&#x3D;xx，不管怎么样，主键肯定会存放的。</p><p><img src="https://cdn.jsdelivr.net/gh/mrqytalk/mrqytalk.github.io@master/image/image-20220417094545460.png" alt="image-20220417094545460"></p><p>在插入数据的时候，MySQL 首先会根据 name 进行排序，如果 name 一样，就根据联合索引中的 age 去排序，如果还一样，那么就会根据 主键 字段去排序。插入的原理就是这样子的。</p><p>假设现在要根据 name 查找到该条记录，且查询的字段（即 select 后面的查询字段）也仅仅有 name（只要是在 name,age,id 这三个字段中都可以）这个时候是能够直接获取到最终的记录的。</p><p>但如果查找的sql语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE name=&#x27;wx&#x27;</span><br></pre></td></tr></table></figure><p>那这下子就完蛋了，因为现在虽然根据 name 很快的定位到了该条记录，但是因为 name+age 不是聚簇索引，此时的 B+ 树的数据页中存放的仅仅是自己关联的索引和主键索引字段，并不会存其他的字段，所以这个时候其他的属性值是获取不到的，这时候该怎么办？</p><p>这种情况下，MySQL 就需要进行<strong>回表</strong>查询了。此时 MySQL 就会根据定位到的某条记录中的 id 再次进行聚簇索引查找，也就是说会根据 id 去维护 id 的 B+ 树中查找。因为聚簇索引中数据页记录的是一条记录的完整的记录，这个过程就叫<strong>回表</strong>。</p><p>回表的含义：<strong>根据非主键索引查询到的结果并没有查找的字段值，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找到的记录才是完成的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Mysql索引简介&quot;&gt;&lt;a href=&quot;#1-Mysql索引简介&quot; class=&quot;headerlink&quot; title=&quot;1. Mysql索引简介&quot;&gt;&lt;/a&gt;1. Mysql索引简介&lt;/h2&gt;&lt;h3 id=&quot;1-1-索引概念&quot;&gt;&lt;a href=&quot;#1-1-索引概</summary>
      
    
    
    
    <category term="数据库" scheme="https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://mrqytalk.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>银行家算法</title>
    <link href="https://mrqytalk.github.io/2022/04/16/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    <id>https://mrqytalk.github.io/2022/04/16/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-16T12:20:20.000Z</published>
    <updated>2022-04-16T13:40:44.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-银行家算法概念"><a href="#1-银行家算法概念" class="headerlink" title="1.  银行家算法概念"></a>1.  银行家算法概念</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p><strong>银行家算法</strong>（Banker’s Algorithm）是一个避免操作系统<a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81">死锁</a>（Deadlock）的著名算法，属于事先预防策略。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。</p><blockquote><p>死锁：当两个以上的运算单元，双方都在等待对方停止执行，以获取系统资源，但是没有一方提前退出时，就称为死锁。</p><p>产生死锁必须<strong>同时满足</strong>以下四个条件：</p><ul><li><p><strong>禁止抢占</strong>（no preemption）：系统资源不能被强制从一个进程中退出。</p></li><li><p><strong>持有和等待</strong>（hold and wait）：一个进程可以在等待时持有系统资源。</p></li><li><p><strong>互斥</strong>（mutual exclusion）：资源只能同时分配给一个行程，无法多个行程共享。</p></li><li><p><strong>循环等待</strong>（circular waiting）：一系列进程互相持有其他进程所需要的资源。</p></li></ul><p>因此，预防死锁需要打破其中一项。</p></blockquote><h3 id="1-2-概括"><a href="#1-2-概括" class="headerlink" title="1.2 概括"></a>1.2 概括</h3><p>当一个进程申请使用资源的时候，银行家算法通过先 <strong>试探</strong> 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若判断结果为安全，则给该进程分配资源，若不安全则试探分配作废，让该进程阻塞。</p><blockquote><p>安全系列不唯一，但只要存在一个就是安全策略，一定不会发生死锁</p></blockquote><h2 id="2-银行家算法具体实现"><a href="#2-银行家算法具体实现" class="headerlink" title="2. 银行家算法具体实现"></a>2. 银行家算法具体实现</h2><h3 id="2-1-术语概念"><a href="#2-1-术语概念" class="headerlink" title="2.1 术语概念"></a>2.1 术语概念</h3><p><code>available</code>:可用资源向量，记录系统中各类资源的当前可利用数目</p><p><code>allocation</code>:记录每个进程中对各类资源当前的占有量</p><p><code>max</code>:记录每个进程对各类资源的最大需求量</p><p><code>need</code>: 记录每个进程中对各类资源当前的需求量，等于max-allocation</p><p><code>request</code>: 请求向量，记录某个进程当前对各类资源的申请量，是银行家算法的入口参数。</p><h3 id="2-2-过程"><a href="#2-2-过程" class="headerlink" title="2.2 过程"></a>2.2 过程</h3><h4 id="2-2-1-先决条件过程"><a href="#2-2-1-先决条件过程" class="headerlink" title="2.2.1 先决条件过程"></a>2.2.1 先决条件过程</h4><ol><li><code>request[i,j]</code>&lt;<code>need[i,j]</code>，否则进程出错</li><li><code>request[i,j]</code>&lt;<code>available[i,j]</code>，否认进程阻塞</li></ol><h4 id="2-2-2-试探分配过程"><a href="#2-2-2-试探分配过程" class="headerlink" title="2.2.2 试探分配过程"></a>2.2.2 试探分配过程</h4><ol start="3"><li><p>系统试着把资源分配给进程P，并对相应数据结构作如下修改：</p><ul><li><p><code>available[i,j]  -request[i,j]</code></p></li><li><p><code>allocation[i,j]+request[i,j]</code></p></li><li><p><code>need[i,j]-request[i,j]</code></p></li></ul></li><li><p>系统执行安全性检测子算法，以判断试分配后系统状态是否安全；</p></li><li><p>若第4步返回逻辑真值，即“安全”，则完成本次分配，返回；</p></li><li><p>否则，撤销此次（即第3步中的）试分配，进程P阻塞。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-银行家算法概念&quot;&gt;&lt;a href=&quot;#1-银行家算法概念&quot; class=&quot;headerlink&quot; title=&quot;1.  银行家算法概念&quot;&gt;&lt;/a&gt;1.  银行家算法概念&lt;/h2&gt;&lt;h3 id=&quot;1-1-介绍&quot;&gt;&lt;a href=&quot;#1-1-介绍&quot; class=&quot;</summary>
      
    
    
    
    <category term="操作系统" scheme="https://mrqytalk.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="算法" scheme="https://mrqytalk.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="操作系统" scheme="https://mrqytalk.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
