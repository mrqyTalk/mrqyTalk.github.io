<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mrqyTalk</title>
  
  
  <link href="https://mrqytalk.github.io/atom.xml" rel="self"/>
  
  <link href="https://mrqytalk.github.io/"/>
  <updated>2022-04-19T07:04:41.025Z</updated>
  <id>https://mrqytalk.github.io/</id>
  
  <author>
    <name>喝水艺术家</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySql存储引擎</title>
    <link href="https://mrqytalk.github.io/2022/04/19/MySql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>https://mrqytalk.github.io/2022/04/19/MySql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
    <published>2022-04-19T07:03:42.000Z</published>
    <updated>2022-04-19T07:04:41.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-存储引擎的相关命令"><a href="#1-存储引擎的相关命令" class="headerlink" title="1. 存储引擎的相关命令"></a>1. 存储引擎的相关命令</h2><ul><li><p>查看mysql提供什么存储引擎并格式化输出：<code>show engines \G; </code></p></li><li><p>查看默认的存储引擎：<code>show variables like &#39;%storage_engine%&#39;;</code></p></li><li><p>修改默认的存储引擎</p><p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：<code>SET DEFAULT_STORAGE_ENGINE=MyISAM; </code>或者修改 my.cnf 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default-storage-engine=MyISAM </span><br><span class="line"># 重启服务</span><br><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure></li><li><p>创建表时指定存储引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(建表语句;) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure></li><li><p>修改表的存储引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-存储引擎介绍"><a href="#2-存储引擎介绍" class="headerlink" title="2. 存储引擎介绍"></a>2. 存储引擎介绍</h2><h3 id="2-1-InnoDB引擎：具备外键支持功能的事务存储引擎"><a href="#2-1-InnoDB引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="2.1  InnoDB引擎：具备外键支持功能的事务存储引擎"></a>2.1  InnoDB引擎：具备外键支持功能的事务存储引擎</h3><ul><li><p>MySQL大于等于5.5之后，默认采用InnoDB引擎 。 </p></li><li><p>InnoDB是MySQL的<code>默认事务型引擎</code> ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</p></li><li><p>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</p></li><li><p><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></p></li><li><p>InnoDB是<strong>为处理巨大数据量的最大性能设计</strong> 。</p></li><li><p>对比MyISAM的存储引擎， <strong>InnoDB写的处理效率差一些</strong> ，并且会占用更多的磁盘空间以保存数据和索引。</p></li><li><p>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， <strong>对内存要求较高</strong> ，而且内存大小对性能有决定性的影响。</p></li></ul><h3 id="2-2-MyISAM和InnoDB的比较"><a href="#2-2-MyISAM和InnoDB的比较" class="headerlink" title="2.2 MyISAM和InnoDB的比较"></a>2.2 MyISAM和InnoDB的比较</h3><table><thead><tr><th align="center">对比项</th><th align="center">MyISAM</th><th align="center">InnoDB</th></tr></thead><tbody><tr><td align="center">外键</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">事务</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">行表锁</td><td align="center">表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td align="center">行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td align="center">缓存</td><td align="center">只缓存索引，不缓存真实数据</td><td align="center">不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td align="center">自带系统表使用</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">关注点</td><td align="center">性能：节省资源、消耗少、简单业务</td><td align="center">事务：并发写、事务、更大资源</td></tr><tr><td align="center">默认安装</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">默认使用</td><td align="center">N</td><td align="center">Y</td></tr></tbody></table><h3 id="2-3-InnoDB表的优势"><a href="#2-3-InnoDB表的优势" class="headerlink" title="2.3 InnoDB表的优势"></a>2.3 InnoDB表的优势</h3><p>InnoDB存储引擎在实际应用中拥有诸多优势，比如操作便利、提高了数据库的性能、维护成本低等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB崩溃恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。</p><p>InnoDB存储引擎在主内存中维护缓冲池，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。</p><p>在专用服务器上，物理内存中高达80%的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃，在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。 <strong>InnoDB不仅支持当前读写，也会缓冲改变的数据到数据流磁盘 。</strong></p><p>InnoDB的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高查询的速度。使用InnoDB可以压缩表和相关的索引，可以 在<strong>不影响性能和可用性的情况下创建或删除索引</strong> 。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。通过查询INFORMATION_SCHEMA库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。 <strong>当处理大数据量时，InnoDB兼顾CPU，以达到最大性能 。</strong> </p><h3 id="2-4-InnoDB架构"><a href="#2-4-InnoDB架构" class="headerlink" title="2.4 InnoDB架构"></a>2.4 InnoDB架构</h3><p><strong>1.</strong> <strong>缓冲池</strong> 缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。</p><p><strong>2.</strong> <strong>更改缓存</strong> 更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分InnoDB缓冲池。在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由innodb_change_buffering配置项管理。</p><p><strong>3.</strong> <strong>自适应哈希索引</strong> <strong>自适应哈希索引将负载和足够的内存结合起来</strong>，使得InnoDB像内存数据库一样运行，不需要降低事务上的性能或可靠性。这个特性通过innodb_adaptive_hash_index选项配置，或者通过– skip-innodb_adaptive_hash_index命令行在服务启动时关闭。</p><p><strong>4.</strong> <strong>重做日志缓存</strong> 重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过innodb_log_buffer_size配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存使得大型事务能够正常运行而不需要写入磁盘。</p><p><strong>5.</strong> <strong>系统表空间</strong> 系统表空间包括InnoDB数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引数据。多表共享，系统表空间被视为共享表空间。</p><p><strong>6.</strong> <strong>双写缓存</strong> 双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存后，InnoDB才会将数据页写入合适的位置。</p><p><strong>7.</strong> <strong>撤销日志</strong> 撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这些片段包含于回滚片段中。</p><p><strong>8.</strong> <strong>每个表一个文件的表空间</strong> 每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中，而不是系统表空间中。这个功能通过innodb_file_per_table配置项开启。每个表空间由一个单独的.ibd数据文件代表，该文件默认被创建在数据库目录中。</p><p><strong>9.</strong> <strong>通用表空间</strong> 使用CREATE TABLESPACE语法创建共享的InnoDB表空间。通用表空间可以创建在MySQL数据目录之外能够管理多个表并支持所有行格式的表。</p><p><strong>10.</strong> <strong>撤销表空间</strong> 撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由innodb_undo_tablespaces配置项配置。</p><p><strong>11.</strong> <strong>临时表空间</strong> 用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。innodb_temp_data_file_path配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在innodb_data_home_dir变量指定的目录下创建一个自动扩展的数据文件。</p><p><strong>12.</strong> <strong>重做日志</strong> 重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间，重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自动在初始化期间重新进行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-存储引擎的相关命令&quot;&gt;&lt;a href=&quot;#1-存储引擎的相关命令&quot; class=&quot;headerlink&quot; title=&quot;1. 存储引擎的相关命令&quot;&gt;&lt;/a&gt;1. 存储引擎的相关命令&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看mysql提供什么存储引擎并格式化输出：&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySql" scheme="https://mrqytalk.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>MySql索引</title>
    <link href="https://mrqytalk.github.io/2022/04/18/MySql%E7%B4%A2%E5%BC%95/"/>
    <id>https://mrqytalk.github.io/2022/04/18/MySql%E7%B4%A2%E5%BC%95/</id>
    <published>2022-04-18T14:48:34.000Z</published>
    <updated>2022-04-18T14:53:37.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Mysql索引简介"><a href="#1-Mysql索引简介" class="headerlink" title="1. Mysql索引简介"></a>1. Mysql索引简介</h2><h3 id="1-1-索引概念"><a href="#1-1-索引概念" class="headerlink" title="1.1 索引概念"></a>1.1 索引概念</h3><p>索引是一个<strong>单独的、存储在磁盘上的、排好序</strong>数据库结构，它们包含着对数据表里所有记录的引用指针。使用索引的功能在于快速找出在某个或多个列中有一特定值的行。</p><h3 id="1-2-索引的分类"><a href="#1-2-索引的分类" class="headerlink" title="1.2 索引的分类"></a>1.2 索引的分类</h3><p>按数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引</strong><br>按物理存储分类可分为：<strong>聚簇索引、二级索引</strong><br>按字段特性分类可分为：<strong>主键索引、普通索引、前缀索引</strong><br>按字段个数分类可分为：<strong>单列索引、联合索引</strong></p><blockquote><p>注：MySQL的索引类型由存储引擎决定，Mysql5.1之前的默认引擎是MyISAM，之后版本是InnoDB。而InnoDB你支持hash索引，但<strong>自适应</strong>Hash索引，即：InnoDB中Hash索引的创建由存储引擎引擎自动优化创建，不能人为干预是否为表创建Hash索引。<strong>因为hash索引只能精确匹配（如select * from user where <code>name</code> &#x3D; xx），不支持范围查找。</strong></p></blockquote><h2 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+树"></a>2. B+树</h2><h3 id="2-1-B-树的特点"><a href="#2-1-B-树的特点" class="headerlink" title="2.1 B+树的特点"></a>2.1 B+树的特点</h3><ul><li><p>在 B+ 树中，<strong>所有数据记录节点都是按照键值的大小存放在同一层的叶子节点上，而非叶子结点只存储key的信息，</strong>这样可以大大减少每个节点的存储的key的数量，降低B+ 树的高度</p></li><li><p>B+ 树叶子节点的关键字从小到大有序排列，<strong>左边结尾数据都会保存右边节点开始数据的指针。</strong></p></li><li><p>B+ 树的层级更少：相较于 B 树， B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快</p></li><li><p>B+ 树查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p></li><li><p>B+ 树天然具备排序功能：<strong>B+ 树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</strong></p></li><li><p>B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p></li></ul><h3 id="2-2-B-树的结构图"><a href="#2-2-B-树的结构图" class="headerlink" title="2.2 B+树的结构图"></a>2.2 B+树的结构图</h3><p><img src="https://cdn.jsdelivr.net/gh/mrqytalk/mrqytalk.github.io@master/image/image-20220417092116463.png" alt="image-20220417092116463"></p><p>Mysql存储的时候以<strong>数据页</strong>为最小单位，数据页与数据页之间通过<strong>双向链表</strong>关联，数据与数据页之间通过<strong>单项链表</strong>关联。</p><p>数据页中的数据是按照主键排序（没有主键是由 MySQL自己维护的 ROW_ID 来排序的），每一个数据页中的页号和最小主键构成<strong>主键目录</strong>。</p><p><strong>索引页+数据页</strong>组成的组成的B+树就是<strong>聚簇索引</strong>。聚簇索引是 MySQL 基于主键索引结构创建的。</p><p>模拟 MySQL 的查找过程，首先从<strong>最顶层的索引页</strong>开始查找，查找 id&#x3D;37，因此定位到了索引页16，然后到索引页 16 中继续查找，此时同样能够定位到 id&#x3D;37 在索引页 3 中，然后继续查找，最终能够定位到数据实在数据页 8 中，加入数据页中8的结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mrqytalk/mrqytalk.github.io@master/image/image-20220417100149016.png" alt="image-20220417100149016"></p><p>完整的数据表：</p><p><img src="https://cdn.jsdelivr.net/gh/mrqytalk/mrqytalk.github.io@master/image/image-20220417100006747.png" alt="image-20220417100006747"></p><h2 id="3-非主键索引"><a href="#3-非主键索引" class="headerlink" title="3. 非主键索引"></a>3. 非主键索引</h2><p>假如现在对<code>name+age(非主键)</code>建立索引，那此时是存放的呢？此时 MySQL 根据会 name+age 维护一个单独的 B+ 树结构，数据依旧是存放在数据页中的，只不过是原来数据中的每条记录写的是 id&#x3D;xx，现在写的是name&#x3D;xx，age&#x3D;xx，id&#x3D;xx，不管怎么样，主键肯定会存放的。</p><p><img src="https://cdn.jsdelivr.net/gh/mrqytalk/mrqytalk.github.io@master/image/image-20220417094545460.png" alt="image-20220417094545460"></p><p>在插入数据的时候，MySQL 首先会根据 name 进行排序，如果 name 一样，就根据联合索引中的 age 去排序，如果还一样，那么就会根据 主键 字段去排序。插入的原理就是这样子的。</p><p>假设现在要根据 name 查找到该条记录，且查询的字段（即 select 后面的查询字段）也仅仅有 name（只要是在 name,age,id 这三个字段中都可以）这个时候是能够直接获取到最终的记录的。</p><p>但如果查找的sql语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE name=&#x27;wx&#x27;</span><br></pre></td></tr></table></figure><p>那这下子就完蛋了，因为现在虽然根据 name 很快的定位到了该条记录，但是因为 name+age 不是聚簇索引，此时的 B+ 树的数据页中存放的仅仅是自己关联的索引和主键索引字段，并不会存其他的字段，所以这个时候其他的属性值是获取不到的，这时候该怎么办？</p><p>这种情况下，MySQL 就需要进行<strong>回表</strong>查询了。此时 MySQL 就会根据定位到的某条记录中的 id 再次进行聚簇索引查找，也就是说会根据 id 去维护 id 的 B+ 树中查找。因为聚簇索引中数据页记录的是一条记录的完整的记录，这个过程就叫<strong>回表</strong>。</p><p>回表的含义：<strong>根据非主键索引查询到的结果并没有查找的字段值，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找到的记录才是完成的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Mysql索引简介&quot;&gt;&lt;a href=&quot;#1-Mysql索引简介&quot; class=&quot;headerlink&quot; title=&quot;1. Mysql索引简介&quot;&gt;&lt;/a&gt;1. Mysql索引简介&lt;/h2&gt;&lt;h3 id=&quot;1-1-索引概念&quot;&gt;&lt;a href=&quot;#1-1-索引概</summary>
      
    
    
    
    <category term="数据库" scheme="https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySql" scheme="https://mrqytalk.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>JVM之类字节码详解</title>
    <link href="https://mrqytalk.github.io/2022/04/18/JVM%E4%B9%8B%E7%B1%BB%E5%AD%97%E8%8A%82%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>https://mrqytalk.github.io/2022/04/18/JVM%E4%B9%8B%E7%B1%BB%E5%AD%97%E8%8A%82%E7%A0%81%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-18T14:44:59.000Z</published>
    <updated>2022-04-18T14:46:57.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-类字节码结构"><a href="#1-类字节码结构" class="headerlink" title="1. 类字节码结构"></a>1. 类字节码结构</h2><blockquote><p>本文参考<a href="https://pdai.tech/">Java全栈知识体系</a>所作笔记，图片版权归作者所有。</p></blockquote><h3 id="1-1-多语言编译为字节码在JVM运行"><a href="#1-1-多语言编译为字节码在JVM运行" class="headerlink" title="1.1 多语言编译为字节码在JVM运行"></a>1.1 多语言编译为字节码在JVM运行</h3><p><strong>计算机是不能直接运行java代码的，必须要先运行java虚拟机，再由java虚拟机运行编译后的java代码。</strong></p><p>为什么jvm不能直接运行java代码呢，这是因为在cpu层面看来计算机中所有的操作都是一个个指令的运行汇集而成的，java是高级语言，只有人类才能理解其逻辑，计算机是无法识别的，所以java代码必须要先编译成字节码文件，jvm才能正确识别代码转换后的指令并将其运行。</p><ul><li>Java代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的JVM虚拟机去读取执行，从而实现一次编写，到处运行的目的。</li><li>JVM也不再只支持Java，由此衍生出了许多基于JVM的编程语言，如Groovy, Scala, Koltin等等。</li></ul><h3 id="1-2-Java字节码文件"><a href="#1-2-Java字节码文件" class="headerlink" title="1.2 Java字节码文件"></a>1.2 Java字节码文件</h3><p>class文件(即字节码文件)本质上是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中。jvm根据其特定的规则解析该二进制数据，从而得到相关信息。</p><p>Class文件采用一种伪结构来存储数据，它有两种类型：无符号数和表。</p><h3 id="1-3-Class文件的结构属性"><a href="#1-3-Class文件的结构属性" class="headerlink" title="1.3 Class文件的结构属性"></a>1.3 Class文件的结构属性</h3><p>字节码文件包含以下类型的数据：</p><p><img src="https://cdn.jsdelivr.net/gh/mrqyTalk/mrqyTalk.github.io@master/image/java-jvm-class-2.png"></p><blockquote><p>魔数：</p><ul><li>在代码中出现但没有解释的数字常量或字符串，又称魔法值，在代码开发中应该尽量避免。</li><li>大多数情况下，我们都是通过扩展名来识别一个文件的类型的，但是扩展名是可以修改的，当一个文件的扩展名被修改过，识别一个文件的类型就必须使用“魔数”。很多类型的文件，其起始的几个字节的内容是固定的（或是有意填充，或是本就如此）这几个字节的内容也被称为魔数，因为根据这几个字节的内容就可以确定文件类型。</li></ul></blockquote><h2 id="2-字节码实现"><a href="#2-字节码实现" class="headerlink" title="2. 字节码实现"></a>2. 字节码实现</h2><h3 id="2-1-编译文件"><a href="#2-1-编译文件" class="headerlink" title="2.1 编译文件"></a>2.1 编译文件</h3><p>以下面的例子为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java  <span class="comment">//通过Javac命令进行编译</span></span><br></pre></td></tr></table></figure><p>以文本形式打开生成的class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cafe babe <span class="number">0000</span> <span class="number">0034</span> <span class="number">0013</span> 0a00 <span class="number">0400</span> 0f09</span><br><span class="line"><span class="number">0003</span> <span class="number">0010</span> <span class="number">0700</span> <span class="number">1107</span> <span class="number">0012</span> <span class="number">0100</span> <span class="number">016d</span> <span class="number">0100</span></span><br><span class="line">0149 <span class="number">0100</span> 063c 696e <span class="number">6974</span> <span class="number">3e01</span> <span class="number">0003</span> <span class="number">2829</span></span><br><span class="line"><span class="number">5601</span> <span class="number">0004</span> <span class="number">436f</span> <span class="number">6465</span> <span class="number">0100</span> 0f4c 696e 654e</span><br><span class="line"><span class="number">756d</span> <span class="number">6265</span> <span class="number">7254</span> <span class="number">6162</span> 6c65 <span class="number">0100</span> 0369 <span class="number">6e63</span></span><br><span class="line"><span class="number">0100</span> 0328 <span class="number">2949</span> <span class="number">0100</span> 0a53 6f75 <span class="number">7263</span> <span class="number">6546</span></span><br><span class="line">696c <span class="number">6501</span> 0009 4d61 696e 2e6a <span class="number">6176</span> 610c</span><br><span class="line"><span class="number">0007</span> 0008 0c00 <span class="number">0500</span> <span class="number">0601</span> <span class="number">0010</span> <span class="number">636f</span> 6d2f</span><br><span class="line"><span class="number">7268</span> <span class="number">7974</span> <span class="number">686d</span> <span class="number">372f</span> 4d61 696e <span class="number">0100</span> 106a</span><br><span class="line"><span class="number">6176</span> <span class="number">612f</span> 6c61 <span class="number">6e67</span> 2f4f 626a <span class="number">6563</span> <span class="number">7400</span></span><br><span class="line"><span class="number">2100</span> <span class="number">0300</span> <span class="number">0400</span> <span class="number">0000</span> <span class="number">0100</span> <span class="number">0200</span> <span class="number">0500</span> <span class="number">0600</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0200</span> <span class="number">0100</span> <span class="number">0700</span> 0800 <span class="number">0100</span> 0900 <span class="number">0000</span></span><br><span class="line">1d00 <span class="number">0100</span> <span class="number">0100</span> <span class="number">0000</span> 052a b700 01b1 <span class="number">0000</span></span><br><span class="line"><span class="number">0001</span> 000a <span class="number">0000</span> <span class="number">0006</span> <span class="number">0001</span> <span class="number">0000</span> <span class="number">0003</span> <span class="number">0001</span></span><br><span class="line">000b 000c <span class="number">0001</span> 0009 <span class="number">0000</span> <span class="number">001f</span> <span class="number">0002</span> <span class="number">0001</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0007</span> 2ab4 <span class="number">0002</span> <span class="number">0460</span> ac00 <span class="number">0000</span> <span class="number">0100</span></span><br><span class="line">0a00 <span class="number">0000</span> <span class="number">0600</span> <span class="number">0100</span> <span class="number">0000</span> 0800 <span class="number">0100</span> 0d00</span><br><span class="line"><span class="number">0000</span> <span class="number">0200</span> 0e</span><br></pre></td></tr></table></figure><ul><li><p>文件开头的4个字节(“cafe babe”)称之为 <code>魔数</code>，唯有以”cafe babe”开头的class文件方可被虚拟机所接受，这4个字节就是字节码文件的身份识别。</p></li><li><p>0000是编译器jdk版本的次版本号0，0034转化为十进制是52,是主版本号，java的版本号从45开始，除1.0和1.1都是使用45.x外,以后每升一个大版本，版本号加一。也就是说，编译生成该class文件的jdk版本为1.8.0。</p></li></ul><h3 id="2-2-反编译字节码文件"><a href="#2-2-反编译字节码文件" class="headerlink" title="2.2 反编译字节码文件"></a>2.2 反编译字节码文件</h3><blockquote><p>使用到java内置的一个反编译工具javap可以反编译字节码文件, 用法: <code>javap &lt;options&gt; &lt;classes&gt;</code></p></blockquote><p>其中，<code>&lt;options&gt;</code>选项包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-help  --help  -?        输出此用法消息</span><br><span class="line">-version                 版本信息</span><br><span class="line">-v  -verbose             输出附加信息</span><br><span class="line">-l                       输出行号和本地变量表</span><br><span class="line">-public                  仅显示公共类和成员</span><br><span class="line">-protected               显示受保护的/公共类和成员</span><br><span class="line">-package                 显示程序包/受保护的/公共类</span><br><span class="line">                         和成员 (默认)</span><br><span class="line">-p  -private             显示所有类和成员</span><br><span class="line">-c                       对代码进行反汇编</span><br><span class="line">-s                       输出内部类型签名</span><br><span class="line">-sysinfo                 显示正在处理的类的</span><br><span class="line">                         系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">-constants               显示最终常量</span><br><span class="line">-classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">-cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">-bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><p>输入命令<code>javap -verbose -p Main.class</code>查看输出内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class <span class="comment">//Class文件当前所在位置，</span></span><br><span class="line">  Last modified <span class="number">2018</span>-<span class="number">4</span>-<span class="number">7</span>; size <span class="number">362</span> bytes <span class="comment">//最后修改时间，文件大小</span></span><br><span class="line">  MD5 checksum 4aed8540b098992663b7ba08c65312de <span class="comment">//MD5值</span></span><br><span class="line">  Compiled from <span class="string">&quot;Main.java&quot;</span> <span class="comment">//编译文件来源</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.rhythm7.Main  <span class="comment">//类的全限定</span></span><br><span class="line">  minor version: <span class="number">0</span>  <span class="comment">//jdk次版本号，</span></span><br><span class="line">  major version: <span class="number">52</span> <span class="comment">//主版本号</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER </span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">4.</span>#<span class="number">18</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">3.</span>#<span class="number">19</span>         <span class="comment">// com/rhythm7/Main.m:I</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">20</span>            <span class="comment">// com/rhythm7/Main</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">21</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">5</span> = Utf8               m</span><br><span class="line">   #<span class="number">6</span> = Utf8               I</span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               Lcom/rhythm7/Main;</span><br><span class="line">  #<span class="number">14</span> = Utf8               inc</span><br><span class="line">  #<span class="number">15</span> = Utf8               ()I</span><br><span class="line">  #<span class="number">16</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">17</span> = Utf8               Main.java</span><br><span class="line">  #<span class="number">18</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">19</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// m:I</span></span><br><span class="line">  #<span class="number">20</span> = Utf8               com/rhythm7/Main</span><br><span class="line">  #<span class="number">21</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> m;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.rhythm7.Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/rhythm7/Main;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field m:I</span></span><br><span class="line">         <span class="number">4</span>: iconst_1</span><br><span class="line">         <span class="number">5</span>: iadd</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/rhythm7/Main;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Main.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开头的7行信息包括:Class文件当前所在位置，最后修改时间，文件大小，MD5值，编译自哪个文件，类的全限定名，jdk次版本号，主版本号。</p><p>然后紧接着的是该类的访问标志：ACC_PUBLIC, ACC_SUPER，访问标志的含义如下:</p><table><thead><tr><th align="center"><strong>标志名称</strong></th><th align="center"><strong>标志值</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">ACC_PUBLIC</td><td align="center">0x0001</td><td align="center">是否为Public类型</td></tr><tr><td align="center">ACC_FINAL</td><td align="center">0x0010</td><td align="center">是否被声明为final，只有类可以设置</td></tr><tr><td align="center">ACC_SUPER</td><td align="center">0x0020</td><td align="center">是否允许使用invokespecial字节码指令的新语义</td></tr><tr><td align="center">ACC_INTERFACE</td><td align="center">0x0200</td><td align="center">标志这是一个接口</td></tr><tr><td align="center">ACC_ABSTRACT</td><td align="center">0x0400</td><td align="center">是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td align="center">ACC_SYNTHETIC</td><td align="center">0x1000</td><td align="center">标志这个类并非由用户代码产生</td></tr><tr><td align="center">ACC_ANNOTATION</td><td align="center">0x2000</td><td align="center">标志这是一个注解</td></tr><tr><td align="center">ACC_ENUM</td><td align="center">0x4000</td><td align="center">标志这是一个枚举</td></tr></tbody></table><h3 id="2-3-常量池-Constant-pool）"><a href="#2-3-常量池-Constant-pool）" class="headerlink" title="2.3 常量池(Constant pool）"></a>2.3 常量池(Constant pool）</h3><p>常量池主要存放的是两大类常量：</p><ul><li>字面量(Literal)</li><li>符号引用(Symbolic References)<ul><li>类和接口的全限定名(Fully Qualified Name)</li><li>字段的名称和描述符号(Descriptor)</li><li>方法的名称和描述符</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span> = Methodref          #<span class="number">4.</span>#<span class="number">18</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">#<span class="number">4</span> = Class              #<span class="number">21</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">#<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">#<span class="number">8</span> = Utf8               ()V</span><br><span class="line">#<span class="number">18</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">#<span class="number">21</span> = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure><p><strong>第一个常量</strong>是一个方法定义，指向了第4和第18个常量。以此类推查看第4和第18个常量。最后可以拼接成第一个常量右侧的注释内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java/lang/Object.<span class="string">&quot;&lt;init&gt;&quot;</span>:()V</span><br></pre></td></tr></table></figure><p>这段可以理解为该类的实例构造器的声明，由于Main类没有重写构造方法，所以调用的是父类的构造方法。此处也说明了Main类的直接父类是Object。 该方法默认返回值是V, 也就是void，无返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">2</span> = Fieldref           #<span class="number">3.</span>#<span class="number">19</span>         <span class="comment">// com/rhythm7/Main.m:I</span></span><br><span class="line">#<span class="number">3</span> = Class              #<span class="number">20</span>            <span class="comment">// com/rhythm7/Main</span></span><br><span class="line">#<span class="number">5</span> = Utf8               m</span><br><span class="line">#<span class="number">6</span> = Utf8               I</span><br><span class="line">#<span class="number">19</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// m:I</span></span><br><span class="line">#<span class="number">20</span> = Utf8               com/rhythm7/Main</span><br></pre></td></tr></table></figure><p>此处声明了一个字段m，类型为I, I即是int类型。关于字节码的类型对应如下：</p><table><thead><tr><th align="center">标识字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">B</td><td align="center">基本类型byte</td></tr><tr><td align="center">C</td><td align="center">基本类型char</td></tr><tr><td align="center">D</td><td align="center">基本类型double</td></tr><tr><td align="center">F</td><td align="center">基本类型float</td></tr><tr><td align="center">I</td><td align="center">基本类型int</td></tr><tr><td align="center">J</td><td align="center">基本类型long</td></tr><tr><td align="center">S</td><td align="center">基本类型short</td></tr><tr><td align="center">Z</td><td align="center">基本类型boolean</td></tr><tr><td align="center">V</td><td align="center">特殊类型void</td></tr><tr><td align="center">L</td><td align="center">对象类型，以分号结尾，如Ljava&#x2F;lang&#x2F;Object;</td></tr></tbody></table><p>对于数组类型，每一位使用一个前置的<code>[</code>字符来描述，如定义一个<code>java.lang.String[][]</code>类型的维数组，将被记录为<code>[[Ljava/lang/String;</code></p><h3 id="2-4-方法表集合"><a href="#2-4-方法表集合" class="headerlink" title="2.4 方法表集合"></a>2.4 方法表集合</h3><p>在常量池之后的是对类内部的方法描述，在字节码中以表的集合形式表现，暂且不管字节码文件的16进制文件内容如何，我们直接看反编译后的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> m;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_PRIVATE</span><br></pre></td></tr></table></figure><p>此处声明了一个私有变量m，类型为int，返回值为int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> com.rhythm7.Main();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/rhythm7/Main;</span><br></pre></td></tr></table></figure><p>这里是构造方法：Main()，返回值为void, 公开方法。</p><p><code>code</code>内的主要属性为：</p><ul><li><p><strong>stack</strong>: 最大操作数栈，JVM运行时会根据这个值来分配栈帧(Frame)中的操作栈深度,此处为1</p></li><li><p><strong>locals</strong>: 局部变量所需的存储空间，单位为Slot, <strong>Slot是虚拟机为局部变量分配内存时所使用的最小单位，为4个字节大小。</strong>方法参数(包括实例方法中的隐藏参数this)，显示异常处理器的参数(try catch中的catch块所定义的异常)，方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是，locals的大小并不一定等于所有局部变量所占的Slot之和，因为局部变量中的Slot是可以重用的。</p></li><li><p><strong>args_size</strong>: 方法参数的个数，这里是1，<strong>因为每个实例方法都会有一个隐藏参数this。</strong></p></li><li><p><strong>attribute_info</strong>: 方法体内容，0,1,4为字节码”行号”，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的”java&#x2F;lang&#x2F;Object.”<init>“:()V, 然后执行返回语句，结束方法。</p></li><li><p><strong>LineNumberTable</strong>: 该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。可以使用 -g:none 或-g:lines选项来取消或要求生成这项信息，如果选择不生成LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。</p></li><li><p><strong>LocalVariableTable</strong>: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是arg0, arg1这样的占位符。 start 表示该局部变量在哪一行开始可见，length表示可见行数，Slot代表所在帧栈位置，Name是变量名称，然后是类型签名。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-类字节码结构&quot;&gt;&lt;a href=&quot;#1-类字节码结构&quot; class=&quot;headerlink&quot; title=&quot;1. 类字节码结构&quot;&gt;&lt;/a&gt;1. 类字节码结构&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文参考&lt;a href=&quot;https://pdai.tech/</summary>
      
    
    
    
    <category term="Java" scheme="https://mrqytalk.github.io/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://mrqytalk.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MySql逻辑架构</title>
    <link href="https://mrqytalk.github.io/2022/04/18/MySql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
    <id>https://mrqytalk.github.io/2022/04/18/MySql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</id>
    <published>2022-04-18T08:01:36.000Z</published>
    <updated>2022-04-18T14:53:25.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Mysql逻辑架构剖析"><a href="#1-Mysql逻辑架构剖析" class="headerlink" title="1. Mysql逻辑架构剖析"></a>1. Mysql逻辑架构剖析</h2><p><strong>1.1</strong> <strong>服务器处理客户端请求</strong></p><p>以查询请求为案例，服务端对客户端的请求处理如下：</p><img src="https://cdn.jsdelivr.net/gh/mrqyTalk/mrqyTalk.github.io@master/image/image-20220418085533068.png" alt="image-20220418085533068" style="zoom: 80%;" /><h3 id="1-2-第一层：连接层"><a href="#1-2-第一层：连接层" class="headerlink" title="1.2 第一层：连接层"></a>1.2 第一层：连接层</h3><p>系统（客户端）访问 <code>MySQL </code>服务器前，做的第一件事就是建立<code> TCP</code> 连接。</p><p>经过三次握手建立连接成功后， <code>MySQL </code>服务器对 <code> TCP</code> 传输过来的账号密码做身份认证、权限获取。</p><ul><li><p><strong>用户名或密码不对，会收到一个<code>Access denied for user</code>错误，客户端程序结束执行</strong></p></li><li><p><strong>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong></p></li></ul><p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><h3 id="1-3-第二层：服务层"><a href="#1-3-第二层：服务层" class="headerlink" title="1.3 第二层：服务层"></a><strong>1.3</strong> 第二层：服务层</h3><ul><li><p><strong>SQL Interface: SQL接口</strong></p><ul><li><p>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface </p></li><li><p>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</p></li></ul></li><li><p><strong>Parser:</strong> <strong>解析器</strong></p><ul><li><p>在解析器中对 SQL 语句进行<strong>语法分析、语义分析</strong>。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</p><blockquote><p>词法分析：你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>语法分析：语法分析器（比如：Bison）会根据语法规则，判断你输</p><p>入的这个 SQL 语句是否 满足 MySQL 语法 。</p></blockquote></li><li><p>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树 ，并根据数据字典丰富查询语法树，会<strong>验证该客户端是否具有执行该查询的权限</strong> 。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。</p></li></ul></li><li><p><strong>Optimizer:</strong> <strong>查询优化器</strong></p><ul><li><p>SQL语句在语法<strong>解析之后、查询之前</strong>会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划 。</p></li><li><p>这个执行计划表明应该<code>使用哪些索引</code>进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p></li><li><p>它使用<code>选取-投影-连接</code>策略进行查询。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where gender =&#x27;女&#x27;</span><br></pre></td></tr></table></figure><p>这个SELECT查询先根据WHERE语句进行<code>选取</code> ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性<code>投影</code> ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 <code>连接</code>起来生成最终查询结果。</p></li></ul></li><li><p><strong>Caches &amp; Buffers： 查询缓存组件</strong></p><ul><li><p>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</p></li><li><p>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</p></li><li><p>这个查询缓存可以在<code>不同客户端之间共享 </code>。 </p></li><li><p>从<code>MySQL 5.7.20</code>开始，不推荐使用查询缓存，并在 <code>MySQL 8.0</code>中删除 。</p></li></ul></li></ul><h3 id="1-4-第三层：引擎层"><a href="#1-4-第三层：引擎层" class="headerlink" title="1.4 第三层：引擎层"></a>1.4 第三层：引擎层</h3><p>插件式存储引擎层（Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p><p>MySQL8默认支持以下的存储引擎如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mrqyTalk/mrqyTalk.github.io@master/image/image-20220418104305891.png" alt="image-20220418104305891"></p><h3 id="1-5-第四层：存储层"><a href="#1-5-第四层：存储层" class="headerlink" title="1.5 第四层：存储层"></a>1.5 第四层：存储层</h3><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。</p><h2 id="2-数据库缓冲池（buffer-pool）"><a href="#2-数据库缓冲池（buffer-pool）" class="headerlink" title="2. 数据库缓冲池（buffer pool）"></a>2. 数据库缓冲池（buffer pool）</h2><p><code>InnoDB</code> 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 <code>I/O </code>需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请<code>占用内存来作为数据缓冲池 </code>，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。</p><p>这样做的好处是可以让磁盘活动最小化，从而<code>减少与磁盘直接进行 I/O 的时间 </code>。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果<strong>索引的数据在缓冲池里，那么访问的成本就会降低很多。</strong></p><h3 id="2-1-缓冲池VS查询缓存"><a href="#2-1-缓冲池VS查询缓存" class="headerlink" title="2.1 缓冲池VS查询缓存"></a>2.1 缓冲池VS查询缓存</h3><p><strong>缓冲池：</strong>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，包括：数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p><p><strong>查询缓存</strong>：是提前把查询结果缓存 起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是<strong>查询对应的结果。</strong>因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p><h3 id="2-2-缓冲池如何读取数据"><a href="#2-2-缓冲池如何读取数据" class="headerlink" title="2.2 缓冲池如何读取数据"></a>2.2 缓冲池如何读取数据</h3><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><h3 id="2-3-查看-x2F-设置缓冲池的大小"><a href="#2-3-查看-x2F-设置缓冲池的大小" class="headerlink" title="2.3 查看&#x2F;设置缓冲池的大小"></a>2.3 查看&#x2F;设置缓冲池的大小</h3><p>查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>缓冲池的value值以bit为单位</p></blockquote><p>修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global innodb_buffer_pool_size = 268435456;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Mysql逻辑架构剖析&quot;&gt;&lt;a href=&quot;#1-Mysql逻辑架构剖析&quot; class=&quot;headerlink&quot; title=&quot;1. Mysql逻辑架构剖析&quot;&gt;&lt;/a&gt;1. Mysql逻辑架构剖析&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.1&lt;/strong&gt; &lt;st</summary>
      
    
    
    
    <category term="数据库" scheme="https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySql" scheme="https://mrqytalk.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>银行家算法</title>
    <link href="https://mrqytalk.github.io/2022/04/16/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    <id>https://mrqytalk.github.io/2022/04/16/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-16T12:20:20.000Z</published>
    <updated>2022-04-16T13:40:44.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-银行家算法概念"><a href="#1-银行家算法概念" class="headerlink" title="1.  银行家算法概念"></a>1.  银行家算法概念</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p><strong>银行家算法</strong>（Banker’s Algorithm）是一个避免操作系统<a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81">死锁</a>（Deadlock）的著名算法，属于事先预防策略。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。</p><blockquote><p>死锁：当两个以上的运算单元，双方都在等待对方停止执行，以获取系统资源，但是没有一方提前退出时，就称为死锁。</p><p>产生死锁必须<strong>同时满足</strong>以下四个条件：</p><ul><li><p><strong>禁止抢占</strong>（no preemption）：系统资源不能被强制从一个进程中退出。</p></li><li><p><strong>持有和等待</strong>（hold and wait）：一个进程可以在等待时持有系统资源。</p></li><li><p><strong>互斥</strong>（mutual exclusion）：资源只能同时分配给一个行程，无法多个行程共享。</p></li><li><p><strong>循环等待</strong>（circular waiting）：一系列进程互相持有其他进程所需要的资源。</p></li></ul><p>因此，预防死锁需要打破其中一项。</p></blockquote><h3 id="1-2-概括"><a href="#1-2-概括" class="headerlink" title="1.2 概括"></a>1.2 概括</h3><p>当一个进程申请使用资源的时候，银行家算法通过先 <strong>试探</strong> 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若判断结果为安全，则给该进程分配资源，若不安全则试探分配作废，让该进程阻塞。</p><blockquote><p>安全系列不唯一，但只要存在一个就是安全策略，一定不会发生死锁</p></blockquote><h2 id="2-银行家算法具体实现"><a href="#2-银行家算法具体实现" class="headerlink" title="2. 银行家算法具体实现"></a>2. 银行家算法具体实现</h2><h3 id="2-1-术语概念"><a href="#2-1-术语概念" class="headerlink" title="2.1 术语概念"></a>2.1 术语概念</h3><p><code>available</code>:可用资源向量，记录系统中各类资源的当前可利用数目</p><p><code>allocation</code>:记录每个进程中对各类资源当前的占有量</p><p><code>max</code>:记录每个进程对各类资源的最大需求量</p><p><code>need</code>: 记录每个进程中对各类资源当前的需求量，等于max-allocation</p><p><code>request</code>: 请求向量，记录某个进程当前对各类资源的申请量，是银行家算法的入口参数。</p><h3 id="2-2-过程"><a href="#2-2-过程" class="headerlink" title="2.2 过程"></a>2.2 过程</h3><h4 id="2-2-1-先决条件过程"><a href="#2-2-1-先决条件过程" class="headerlink" title="2.2.1 先决条件过程"></a>2.2.1 先决条件过程</h4><ol><li><code>request[i,j]</code>&lt;<code>need[i,j]</code>，否则进程出错</li><li><code>request[i,j]</code>&lt;<code>available[i,j]</code>，否认进程阻塞</li></ol><h4 id="2-2-2-试探分配过程"><a href="#2-2-2-试探分配过程" class="headerlink" title="2.2.2 试探分配过程"></a>2.2.2 试探分配过程</h4><ol start="3"><li><p>系统试着把资源分配给进程P，并对相应数据结构作如下修改：</p><ul><li><p><code>available[i,j]  -request[i,j]</code></p></li><li><p><code>allocation[i,j]+request[i,j]</code></p></li><li><p><code>need[i,j]-request[i,j]</code></p></li></ul></li><li><p>系统执行安全性检测子算法，以判断试分配后系统状态是否安全；</p></li><li><p>若第4步返回逻辑真值，即“安全”，则完成本次分配，返回；</p></li><li><p>否则，撤销此次（即第3步中的）试分配，进程P阻塞。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-银行家算法概念&quot;&gt;&lt;a href=&quot;#1-银行家算法概念&quot; class=&quot;headerlink&quot; title=&quot;1.  银行家算法概念&quot;&gt;&lt;/a&gt;1.  银行家算法概念&lt;/h2&gt;&lt;h3 id=&quot;1-1-介绍&quot;&gt;&lt;a href=&quot;#1-1-介绍&quot; class=&quot;</summary>
      
    
    
    
    <category term="操作系统" scheme="https://mrqytalk.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="算法" scheme="https://mrqytalk.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="操作系统" scheme="https://mrqytalk.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
