{"meta":{"title":"mrqyTalk","subtitle":"","description":"","author":"吴同学","url":"https://mrqytalk.github.io","root":"/"},"pages":[],"posts":[{"title":"JavaWeb笔记","slug":"JavaWeb笔记","date":"2022-04-15T11:53:47.000Z","updated":"2022-04-15T12:01:17.064Z","comments":true,"path":"2022/04/15/JavaWeb笔记/","link":"","permalink":"https://mrqytalk.github.io/2022/04/15/JavaWeb%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一、servlet1、servlet继承关系及参数1）继承关系：Httpservlet-&gt;Genericservlet-&gt;Servlet 2）Servlet中的核心方法：init（），service（），destroy（） 3）服务方法：当有请求过来时，service方法会自动响应（其实是tomcat容器调用的），在HttpServlet中我们会去分析请求的方式：到底是get、post、head还是delete等等，然后再决定调用的是哪个do开头的方法，那么在HttpServlet中这些do方法默认都是405的实现风格—–要我们子类去实现对应的方法，否则默认会报405错误。 4）因此，我们在新建servlet时，我们才会去考虑请求方法，从而决定重写哪个do方法。 2、servlet生命周期 生命周期：从出生到死亡的过程就是生命周期。对应servlet中的三个方法：init（），service（），destroy（） 默认情况下：第一次接收请求时，这个servlet会进行实例化（调用构造方法）、初始化（调用init（））、然后服务（调用service（）），从第二次请求开始，每一次都是服务，当容器关闭时，其中的所有的servlet实例会被销毁，调用销毁方法。 通过案例我们发现：Servlet实例tomcat只会创建一个，所有的请求都是这个实例去响应。 默认情况下，第一次请求时，tomcat才会去实例化，初始化，然后再服务.这样的好处是什么？提高系统的启动速度，因此得出结论：如果需要提高系统的启动速度，当前默认情况就是这样。如果需要提高响应速度，我们应该设置servlet的初始化时机。 servlet的初始化时机： —-默认是第一次接收请求时，实例化，初始化 —-我们可以通过来设置servlet启动的先后顺序，数字越小，启动越靠前，最小值0。 Servlet是单例的，线程是不安全的。 单例：所有的请求都是同一个实例去响应 线程不安全：一个线程需要根据这个实例中的某个成员变量值去做逻辑判断，但是中间某个时机，另一个线程改变了这个成员变量的值，从而导致第一个线程改变执行路径。因此，尽量不要在servlet中定义成员变量。如果不得不定义成员变量，那么不要去修改成员变量的值，不要根据成员变量的值去做一些逻辑判断。 3、HTTP相关3.1会话跟踪技术 客户端第一次发请求给服务器，服务器获取session，获取不到，则创建新的，然后响应给客户端 下次客户端给服务器发请求时，会把sessionID带给服务器，那么服务器就能获取到了，那么服务器就判断这一次请求和上次相同。 常用的API： request.getSession（）-&gt;获取当前的会话，没有则创建一个新的会话 request.getSession（true）-&gt;效果和不带参数相同 request.getSession（false）-&gt;获取当前会话，没有则返回nu11，不会创建新的 session.getId（）-&gt;获取sessionID session.isNew（）-&gt;判断当前session是否是新的 session.getMaxInactiveInter（）-&gt;session的非激活间隔时长，默认1800秒 session.invalidate（）-&gt;强制性让会话立即失效 3.2session作用域 session保存作用域是和具体的某一个session对应的 常用的API: 123void session.setAttribute（k，v）object session.getAttribute（k）void removeAttribute（k） 3.3服务端内部转发及重定向 服务器内部转发：request.getRequestDispatcher（”…”）.forward（request，response）； 一次请求响应的过程，对于客户端而言，内部经过了多少次转发，客户端是不知道的 地址栏没有变化 客户端重定向：response.sendRedirect（”….”）； 两次请求响应的过程。客户端肯定知道请求UR工有变化 地址栏有变化 3.4session保存作用域原始情况下，保存作用域我们可以认为有四个： page（页面级别，现在几乎不用） request：一次请求响应范围 session：一次会话范围有效 application：一次应用程序范围有效 4、Filter过滤器 过滤器Filter 1）Filter也属于servlet规范2）Filter开发步骤：新建类实现Filter接口，然后实现其中的三个方法：init、doFilter、destroy配置Filter，可以用注解@webFilter，也可以使用xm1文件3）Filter在配置时，和servlet一样，也可以配置通配符，例如@WebFilter（”*.do”）表示拦截所有以.do结尾的请求 过滤器链1）执行的顺序依次是：ABC demo03 C2 B2 A2 2）如果采取的是注解的方式进行配置，那么过滤器链的拦截顺序是按照全类名的先后顺序排序的 3）如果采取的是xm1的方式进行配置，那么按照配置的先后顺序进行排序","categories":[{"name":"Java","slug":"Java","permalink":"https://mrqytalk.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://mrqytalk.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://mrqytalk.github.io/tags/JavaWeb/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-14T03:00:47.266Z","updated":"2022-04-14T03:00:47.267Z","comments":true,"path":"2022/04/14/hello-world/","link":"","permalink":"https://mrqytalk.github.io/2022/04/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://mrqytalk.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://mrqytalk.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://mrqytalk.github.io/tags/JavaWeb/"}]}