{"meta":{"title":"mrqyTalk","subtitle":"","description":"","author":"喝水艺术家","url":"https://mrqytalk.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-04-14T03:13:06.820Z","updated":"2022-04-14T03:13:06.820Z","comments":false,"path":"/404.html","permalink":"https://mrqytalk.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2022-04-14T03:13:06.823Z","updated":"2022-04-14T03:13:06.823Z","comments":false,"path":"books/index.html","permalink":"https://mrqytalk.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-04-14T03:13:06.822Z","updated":"2022-04-14T03:13:06.822Z","comments":false,"path":"about/index.html","permalink":"https://mrqytalk.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-04-16T12:25:45.369Z","updated":"2022-04-16T00:08:36.553Z","comments":false,"path":"categories/index.html","permalink":"https://mrqytalk.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-16T00:36:54.461Z","updated":"2022-04-16T00:36:54.461Z","comments":false,"path":"tags/index.html","permalink":"https://mrqytalk.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-04-17T06:24:55.940Z","updated":"2022-04-17T06:24:55.940Z","comments":false,"path":"links/index.html","permalink":"https://mrqytalk.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-04-14T03:13:06.826Z","updated":"2022-04-14T03:13:06.826Z","comments":false,"path":"repository/index.html","permalink":"https://mrqytalk.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"MySql索引","slug":"MySql索引","date":"2022-04-18T14:48:34.000Z","updated":"2022-04-18T14:53:37.445Z","comments":false,"path":"2022/04/18/MySql索引/","link":"","permalink":"https://mrqytalk.github.io/2022/04/18/MySql%E7%B4%A2%E5%BC%95/","excerpt":"","text":"1. Mysql索引简介1.1 索引概念索引是一个单独的、存储在磁盘上的、排好序数据库结构，它们包含着对数据表里所有记录的引用指针。使用索引的功能在于快速找出在某个或多个列中有一特定值的行。 1.2 索引的分类按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引按物理存储分类可分为：聚簇索引、二级索引按字段特性分类可分为：主键索引、普通索引、前缀索引按字段个数分类可分为：单列索引、联合索引 注：MySQL的索引类型由存储引擎决定，Mysql5.1之前的默认引擎是MyISAM，之后版本是InnoDB。而InnoDB你支持hash索引，但自适应Hash索引，即：InnoDB中Hash索引的创建由存储引擎引擎自动优化创建，不能人为干预是否为表创建Hash索引。因为hash索引只能精确匹配（如select * from user where name &#x3D; xx），不支持范围查找。 2. B+树2.1 B+树的特点 在 B+ 树中，所有数据记录节点都是按照键值的大小存放在同一层的叶子节点上，而非叶子结点只存储key的信息，这样可以大大减少每个节点的存储的key的数量，降低B+ 树的高度 B+ 树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。 B+ 树的层级更少：相较于 B 树， B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快 B+ 树查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定; B+ 树天然具备排序功能：B+ 树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。 B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 2.2 B+树的结构图 Mysql存储的时候以数据页为最小单位，数据页与数据页之间通过双向链表关联，数据与数据页之间通过单项链表关联。 数据页中的数据是按照主键排序（没有主键是由 MySQL自己维护的 ROW_ID 来排序的），每一个数据页中的页号和最小主键构成主键目录。 索引页+数据页组成的组成的B+树就是聚簇索引。聚簇索引是 MySQL 基于主键索引结构创建的。 模拟 MySQL 的查找过程，首先从最顶层的索引页开始查找，查找 id&#x3D;37，因此定位到了索引页16，然后到索引页 16 中继续查找，此时同样能够定位到 id&#x3D;37 在索引页 3 中，然后继续查找，最终能够定位到数据实在数据页 8 中，加入数据页中8的结构如下： 完整的数据表： 3. 非主键索引假如现在对name+age(非主键)建立索引，那此时是存放的呢？此时 MySQL 根据会 name+age 维护一个单独的 B+ 树结构，数据依旧是存放在数据页中的，只不过是原来数据中的每条记录写的是 id&#x3D;xx，现在写的是name&#x3D;xx，age&#x3D;xx，id&#x3D;xx，不管怎么样，主键肯定会存放的。 在插入数据的时候，MySQL 首先会根据 name 进行排序，如果 name 一样，就根据联合索引中的 age 去排序，如果还一样，那么就会根据 主键 字段去排序。插入的原理就是这样子的。 假设现在要根据 name 查找到该条记录，且查询的字段（即 select 后面的查询字段）也仅仅有 name（只要是在 name,age,id 这三个字段中都可以）这个时候是能够直接获取到最终的记录的。 但如果查找的sql语句如下： 1SELECT * FROM student WHERE name=&#x27;wx&#x27; 那这下子就完蛋了，因为现在虽然根据 name 很快的定位到了该条记录，但是因为 name+age 不是聚簇索引，此时的 B+ 树的数据页中存放的仅仅是自己关联的索引和主键索引字段，并不会存其他的字段，所以这个时候其他的属性值是获取不到的，这时候该怎么办？ 这种情况下，MySQL 就需要进行回表查询了。此时 MySQL 就会根据定位到的某条记录中的 id 再次进行聚簇索引查找，也就是说会根据 id 去维护 id 的 B+ 树中查找。因为聚簇索引中数据页记录的是一条记录的完整的记录，这个过程就叫回表。 回表的含义：根据非主键索引查询到的结果并没有查找的字段值，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找到的记录才是完成的。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://mrqytalk.github.io/tags/MySql/"}]},{"title":"JVM之类字节码详解","slug":"JVM之类字节码详解","date":"2022-04-18T14:44:59.000Z","updated":"2022-04-18T14:46:57.630Z","comments":false,"path":"2022/04/18/JVM之类字节码详解/","link":"","permalink":"https://mrqytalk.github.io/2022/04/18/JVM%E4%B9%8B%E7%B1%BB%E5%AD%97%E8%8A%82%E7%A0%81%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"1. 类字节码结构 本文参考Java全栈知识体系所作笔记，图片版权归作者所有。 1.1 多语言编译为字节码在JVM运行计算机是不能直接运行java代码的，必须要先运行java虚拟机，再由java虚拟机运行编译后的java代码。 为什么jvm不能直接运行java代码呢，这是因为在cpu层面看来计算机中所有的操作都是一个个指令的运行汇集而成的，java是高级语言，只有人类才能理解其逻辑，计算机是无法识别的，所以java代码必须要先编译成字节码文件，jvm才能正确识别代码转换后的指令并将其运行。 Java代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的JVM虚拟机去读取执行，从而实现一次编写，到处运行的目的。 JVM也不再只支持Java，由此衍生出了许多基于JVM的编程语言，如Groovy, Scala, Koltin等等。 1.2 Java字节码文件class文件(即字节码文件)本质上是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中。jvm根据其特定的规则解析该二进制数据，从而得到相关信息。 Class文件采用一种伪结构来存储数据，它有两种类型：无符号数和表。 1.3 Class文件的结构属性字节码文件包含以下类型的数据： 魔数： 在代码中出现但没有解释的数字常量或字符串，又称魔法值，在代码开发中应该尽量避免。 大多数情况下，我们都是通过扩展名来识别一个文件的类型的，但是扩展名是可以修改的，当一个文件的扩展名被修改过，识别一个文件的类型就必须使用“魔数”。很多类型的文件，其起始的几个字节的内容是固定的（或是有意填充，或是本就如此）这几个字节的内容也被称为魔数，因为根据这几个字节的内容就可以确定文件类型。 2. 字节码实现2.1 编译文件以下面的例子为例： 123456789//Main.javapublic class Main &#123; private int m; public int inc() &#123; return m + 1; &#125;&#125; 1javac Main.java //通过Javac命令进行编译 以文本形式打开生成的class文件： 123456789101112131415161718cafe babe 0000 0034 0013 0a00 0400 0f090003 0010 0700 1107 0012 0100 016d 01000149 0100 063c 696e 6974 3e01 0003 28295601 0004 436f 6465 0100 0f4c 696e 654e756d 6265 7254 6162 6c65 0100 0369 6e630100 0328 2949 0100 0a53 6f75 7263 6546696c 6501 0009 4d61 696e 2e6a 6176 610c0007 0008 0c00 0500 0601 0010 636f 6d2f7268 7974 686d 372f 4d61 696e 0100 106a6176 612f 6c61 6e67 2f4f 626a 6563 74002100 0300 0400 0000 0100 0200 0500 06000000 0200 0100 0700 0800 0100 0900 00001d00 0100 0100 0000 052a b700 01b1 00000001 000a 0000 0006 0001 0000 0003 0001000b 000c 0001 0009 0000 001f 0002 00010000 0007 2ab4 0002 0460 ac00 0000 01000a00 0000 0600 0100 0000 0800 0100 0d000000 0200 0e 文件开头的4个字节(“cafe babe”)称之为 魔数，唯有以”cafe babe”开头的class文件方可被虚拟机所接受，这4个字节就是字节码文件的身份识别。 0000是编译器jdk版本的次版本号0，0034转化为十进制是52,是主版本号，java的版本号从45开始，除1.0和1.1都是使用45.x外,以后每升一个大版本，版本号加一。也就是说，编译生成该class文件的jdk版本为1.8.0。 2.2 反编译字节码文件 使用到java内置的一个反编译工具javap可以反编译字节码文件, 用法: javap &lt;options&gt; &lt;classes&gt; 其中，&lt;options&gt;选项包括： 1234567891011121314151617-help --help -? 输出此用法消息-version 版本信息-v -verbose 输出附加信息-l 输出行号和本地变量表-public 仅显示公共类和成员-protected 显示受保护的/公共类和成员-package 显示程序包/受保护的/公共类 和成员 (默认)-p -private 显示所有类和成员-c 对代码进行反汇编-s 输出内部类型签名-sysinfo 显示正在处理的类的 系统信息 (路径, 大小, 日期, MD5 散列)-constants 显示最终常量-classpath &lt;path&gt; 指定查找用户类文件的位置-cp &lt;path&gt; 指定查找用户类文件的位置-bootclasspath &lt;path&gt; 覆盖引导类文件的位置 输入命令javap -verbose -p Main.class查看输出内容: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class //Class文件当前所在位置， Last modified 2018-4-7; size 362 bytes //最后修改时间，文件大小 MD5 checksum 4aed8540b098992663b7ba08c65312de //MD5值 Compiled from &quot;Main.java&quot; //编译文件来源 public class com.rhythm7.Main //类的全限定 minor version: 0 //jdk次版本号， major version: 52 //主版本号 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #4.#18 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #3.#19 // com/rhythm7/Main.m:I #3 = Class #20 // com/rhythm7/Main #4 = Class #21 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/rhythm7/Main; #14 = Utf8 inc #15 = Utf8 ()I #16 = Utf8 SourceFile #17 = Utf8 Main.java #18 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #19 = NameAndType #5:#6 // m:I #20 = Utf8 com/rhythm7/Main #21 = Utf8 java/lang/Object&#123; private int m; descriptor: I flags: ACC_PRIVATE public com.rhythm7.Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/rhythm7/Main; public int inc(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 8: 0 LocalVariableTable: Start Length Slot Name Signature 0 7 0 this Lcom/rhythm7/Main;&#125;SourceFile: &quot;Main.java&quot; 开头的7行信息包括:Class文件当前所在位置，最后修改时间，文件大小，MD5值，编译自哪个文件，类的全限定名，jdk次版本号，主版本号。 然后紧接着的是该类的访问标志：ACC_PUBLIC, ACC_SUPER，访问标志的含义如下: 标志名称 标志值 含义 ACC_PUBLIC 0x0001 是否为Public类型 ACC_FINAL 0x0010 是否被声明为final，只有类可以设置 ACC_SUPER 0x0020 是否允许使用invokespecial字节码指令的新语义 ACC_INTERFACE 0x0200 标志这是一个接口 ACC_ABSTRACT 0x0400 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 ACC_SYNTHETIC 0x1000 标志这个类并非由用户代码产生 ACC_ANNOTATION 0x2000 标志这是一个注解 ACC_ENUM 0x4000 标志这是一个枚举 2.3 常量池(Constant pool）常量池主要存放的是两大类常量： 字面量(Literal) 符号引用(Symbolic References) 类和接口的全限定名(Fully Qualified Name) 字段的名称和描述符号(Descriptor) 方法的名称和描述符 123456#1 = Methodref #4.#18 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V#4 = Class #21 // java/lang/Object#7 = Utf8 &lt;init&gt;#8 = Utf8 ()V#18 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V#21 = Utf8 java/lang/Object 第一个常量是一个方法定义，指向了第4和第18个常量。以此类推查看第4和第18个常量。最后可以拼接成第一个常量右侧的注释内容: 1java/lang/Object.&quot;&lt;init&gt;&quot;:()V 这段可以理解为该类的实例构造器的声明，由于Main类没有重写构造方法，所以调用的是父类的构造方法。此处也说明了Main类的直接父类是Object。 该方法默认返回值是V, 也就是void，无返回值。 123456#2 = Fieldref #3.#19 // com/rhythm7/Main.m:I#3 = Class #20 // com/rhythm7/Main#5 = Utf8 m#6 = Utf8 I#19 = NameAndType #5:#6 // m:I#20 = Utf8 com/rhythm7/Main 此处声明了一个字段m，类型为I, I即是int类型。关于字节码的类型对应如下： 标识字符 含义 B 基本类型byte C 基本类型char D 基本类型double F 基本类型float I 基本类型int J 基本类型long S 基本类型short Z 基本类型boolean V 特殊类型void L 对象类型，以分号结尾，如Ljava&#x2F;lang&#x2F;Object; 对于数组类型，每一位使用一个前置的[字符来描述，如定义一个java.lang.String[][]类型的维数组，将被记录为[[Ljava/lang/String; 2.4 方法表集合在常量池之后的是对类内部的方法描述，在字节码中以表的集合形式表现，暂且不管字节码文件的16进制文件内容如何，我们直接看反编译后的内容。 123private int m; descriptor: I flags: ACC_PRIVATE 此处声明了一个私有变量m，类型为int，返回值为int 12345678910111213public com.rhythm7.Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/rhythm7/Main; 这里是构造方法：Main()，返回值为void, 公开方法。 code内的主要属性为： stack: 最大操作数栈，JVM运行时会根据这个值来分配栈帧(Frame)中的操作栈深度,此处为1 locals: 局部变量所需的存储空间，单位为Slot, Slot是虚拟机为局部变量分配内存时所使用的最小单位，为4个字节大小。方法参数(包括实例方法中的隐藏参数this)，显示异常处理器的参数(try catch中的catch块所定义的异常)，方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是，locals的大小并不一定等于所有局部变量所占的Slot之和，因为局部变量中的Slot是可以重用的。 args_size: 方法参数的个数，这里是1，因为每个实例方法都会有一个隐藏参数this。 attribute_info: 方法体内容，0,1,4为字节码”行号”，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的”java&#x2F;lang&#x2F;Object.”“:()V, 然后执行返回语句，结束方法。 LineNumberTable: 该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。可以使用 -g:none 或-g:lines选项来取消或要求生成这项信息，如果选择不生成LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。 LocalVariableTable: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是arg0, arg1这样的占位符。 start 表示该局部变量在哪一行开始可见，length表示可见行数，Slot代表所在帧栈位置，Name是变量名称，然后是类型签名。","categories":[{"name":"Java","slug":"Java","permalink":"https://mrqytalk.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://mrqytalk.github.io/tags/JVM/"}]},{"title":"MySql逻辑架构","slug":"MySql逻辑架构","date":"2022-04-18T08:01:36.000Z","updated":"2022-04-18T14:53:25.208Z","comments":false,"path":"2022/04/18/MySql逻辑架构/","link":"","permalink":"https://mrqytalk.github.io/2022/04/18/MySql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/","excerpt":"","text":"1. Mysql逻辑架构剖析1.1 服务器处理客户端请求 以查询请求为案例，服务端对客户端的请求处理如下： 1.2 第一层：连接层系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。 用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行 用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限 TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。 1.3 第二层：服务层 SQL Interface: SQL接口 接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口 Parser: 解析器 在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。 词法分析：你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。 语法分析：语法分析器（比如：Bison）会根据语法规则，判断你输 入的这个 SQL 语句是否 满足 MySQL 语法 。 在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树 ，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。 Optimizer: 查询优化器 SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划 。 这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。 它使用选取-投影-连接策略进行查询。例如： 1select * from student where gender =&#x27;女&#x27; 这个SELECT查询先根据WHERE语句进行选取 ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性投影 ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 连接起来生成最终查询结果。 Caches &amp; Buffers： 查询缓存组件 MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 这个查询缓存可以在不同客户端之间共享 。 从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。 1.4 第三层：引擎层插件式存储引擎层（Storage Engines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。 MySQL8默认支持以下的存储引擎如下： 1.5 第四层：存储层所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。 2. 数据库缓冲池（buffer pool）InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请占用内存来作为数据缓冲池 ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。 这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行 I/O 的时间 。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。 2.1 缓冲池VS查询缓存缓冲池：在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，包括：数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。 查询缓存：是提前把查询结果缓存 起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。 2.2 缓冲池如何读取数据缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。 2.3 查看&#x2F;设置缓冲池的大小查看： 1show variables like &#x27;innodb_buffer_pool_size&#x27;; 缓冲池的value值以bit为单位 修改： 1set global innodb_buffer_pool_size = 268435456;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://mrqytalk.github.io/tags/MySql/"}]},{"title":"银行家算法","slug":"银行家算法","date":"2022-04-16T12:20:20.000Z","updated":"2022-04-16T13:40:44.418Z","comments":false,"path":"2022/04/16/银行家算法/","link":"","permalink":"https://mrqytalk.github.io/2022/04/16/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/","excerpt":"","text":"1. 银行家算法概念1.1 介绍银行家算法（Banker’s Algorithm）是一个避免操作系统死锁（Deadlock）的著名算法，属于事先预防策略。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。 死锁：当两个以上的运算单元，双方都在等待对方停止执行，以获取系统资源，但是没有一方提前退出时，就称为死锁。 产生死锁必须同时满足以下四个条件： 禁止抢占（no preemption）：系统资源不能被强制从一个进程中退出。 持有和等待（hold and wait）：一个进程可以在等待时持有系统资源。 互斥（mutual exclusion）：资源只能同时分配给一个行程，无法多个行程共享。 循环等待（circular waiting）：一系列进程互相持有其他进程所需要的资源。 因此，预防死锁需要打破其中一项。 1.2 概括当一个进程申请使用资源的时候，银行家算法通过先 试探 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若判断结果为安全，则给该进程分配资源，若不安全则试探分配作废，让该进程阻塞。 安全系列不唯一，但只要存在一个就是安全策略，一定不会发生死锁 2. 银行家算法具体实现2.1 术语概念available:可用资源向量，记录系统中各类资源的当前可利用数目 allocation:记录每个进程中对各类资源当前的占有量 max:记录每个进程对各类资源的最大需求量 need: 记录每个进程中对各类资源当前的需求量，等于max-allocation request: 请求向量，记录某个进程当前对各类资源的申请量，是银行家算法的入口参数。 2.2 过程2.2.1 先决条件过程 request[i,j]&lt;need[i,j]，否则进程出错 request[i,j]&lt;available[i,j]，否认进程阻塞 2.2.2 试探分配过程 系统试着把资源分配给进程P，并对相应数据结构作如下修改： available[i,j] -request[i,j] allocation[i,j]+request[i,j] need[i,j]-request[i,j] 系统执行安全性检测子算法，以判断试分配后系统状态是否安全； 若第4步返回逻辑真值，即“安全”，则完成本次分配，返回； 否则，撤销此次（即第3步中的）试分配，进程P阻塞。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://mrqytalk.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://mrqytalk.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"操作系统","slug":"操作系统","permalink":"https://mrqytalk.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java","slug":"Java","permalink":"https://mrqytalk.github.io/categories/Java/"},{"name":"操作系统","slug":"操作系统","permalink":"https://mrqytalk.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://mrqytalk.github.io/tags/MySql/"},{"name":"JVM","slug":"JVM","permalink":"https://mrqytalk.github.io/tags/JVM/"},{"name":"算法","slug":"算法","permalink":"https://mrqytalk.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"操作系统","slug":"操作系统","permalink":"https://mrqytalk.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}