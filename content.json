{"meta":{"title":"mrqyTalk","subtitle":"","description":"","author":"吴同学","url":"https://mrqytalk.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2022-04-17T06:24:55.940Z","updated":"2022-04-17T06:24:55.940Z","comments":false,"path":"links/index.html","permalink":"https://mrqytalk.github.io/links/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-04-14T03:13:06.820Z","updated":"2022-04-14T03:13:06.820Z","comments":false,"path":"/404.html","permalink":"https://mrqytalk.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2022-04-14T03:13:06.823Z","updated":"2022-04-14T03:13:06.823Z","comments":false,"path":"books/index.html","permalink":"https://mrqytalk.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-16T12:25:45.369Z","updated":"2022-04-16T00:08:36.553Z","comments":false,"path":"categories/index.html","permalink":"https://mrqytalk.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-04-14T03:13:06.822Z","updated":"2022-04-14T03:13:06.822Z","comments":false,"path":"about/index.html","permalink":"https://mrqytalk.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2022-04-16T00:36:54.461Z","updated":"2022-04-16T00:36:54.461Z","comments":false,"path":"tags/index.html","permalink":"https://mrqytalk.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-04-14T03:13:06.826Z","updated":"2022-04-14T03:13:06.826Z","comments":false,"path":"repository/index.html","permalink":"https://mrqytalk.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"MySql逻辑架构","slug":"MySql逻辑架构","date":"2022-04-18T08:01:36.000Z","updated":"2022-04-18T08:07:00.668Z","comments":false,"path":"2022/04/18/MySql逻辑架构/","link":"","permalink":"https://mrqytalk.github.io/2022/04/18/MySql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/","excerpt":"","text":"1. Mysql逻辑架构剖析1.1 服务器处理客户端请求 以查询请求为案例，服务端对客户端的请求处理如下： 1.2 第一层：连接层系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。 用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行 用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限 TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。 1.3 第2层：服务层 SQL Interface: SQL接口 接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口 Parser: 解析器 在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。 词法分析：你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。 语法分析：语法分析器（比如：Bison）会根据语法规则，判断你输 入的这个 SQL 语句是否 满足 MySQL 语法 。 在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树 ，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。 Optimizer: 查询优化器 SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划 。 这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。 它使用选取-投影-连接策略进行查询。例如： 1select * from student where gender =&#x27;女&#x27; 这个SELECT查询先根据WHERE语句进行选取 ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性投影 ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 连接起来生成最终查询结果。 Caches &amp; Buffers： 查询缓存组件 MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 这个查询缓存可以在不同客户端之间共享 。 从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。 1.4 第3层：引擎层插件式存储引擎层（Storage Engines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。 MySQL8默认支持以下的存储引擎如下： 1.5 存储层所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。 2. 数据库缓冲池（buffer pool）InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请占用内存来作为数据缓冲池 ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。 这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行 I/O 的时间 。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。 2.1 缓冲池VS查询缓存缓冲池：在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，包括：数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。 查询缓存：是提前把查询结果缓存 起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。 2.2 缓冲池如何读取数据缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。 2.3 查看&#x2F;设置缓冲池的大小查看： 1show variables like &#x27;innodb_buffer_pool_size&#x27;; 缓冲池的value值以bit为单位 修改： 1set global innodb_buffer_pool_size = 268435456;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://mrqytalk.github.io/tags/Mysql/"}]},{"title":"mysql索引","slug":"mysql索引","date":"2022-04-17T03:57:26.000Z","updated":"2022-04-17T04:04:21.178Z","comments":false,"path":"2022/04/17/mysql索引/","link":"","permalink":"https://mrqytalk.github.io/2022/04/17/mysql%E7%B4%A2%E5%BC%95/","excerpt":"","text":"1. Mysql索引简介1.1 索引概念索引是一个单独的、存储在磁盘上的、排好序数据库结构，它们包含着对数据表里所有记录的引用指针。使用索引的功能在于快速找出在某个或多个列中有一特定值的行。 1.2 索引的分类按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引按物理存储分类可分为：聚簇索引、二级索引按字段特性分类可分为：主键索引、普通索引、前缀索引按字段个数分类可分为：单列索引、联合索引 注：MySQL的索引类型由存储引擎决定，Mysql5.1之前的默认引擎是MyISAM，之后版本是InnoDB。而InnoDB你支持hash索引，但自适应Hash索引，即：InnoDB中Hash索引的创建由存储引擎引擎自动优化创建，不能人为干预是否为表创建Hash索引。因为hash索引只能精确匹配（如select * from user where name &#x3D; xx），不支持范围查找。 2. B+树2.1 B+树的特点 在 B+ 树中，所有数据记录节点都是按照键值的大小存放在同一层的叶子节点上，而非叶子结点只存储key的信息，这样可以大大减少每个节点的存储的key的数量，降低B+ 树的高度 B+ 树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。 B+ 树的层级更少：相较于 B 树， B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快 B+ 树查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定; B+ 树天然具备排序功能：B+ 树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。 B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 2.2 B+树的结构图 Mysql存储的时候以数据页为最小单位，数据页与数据页之间通过双向链表关联，数据与数据页之间通过单项链表关联。 数据页中的数据是按照主键排序（没有主键是由 MySQL自己维护的 ROW_ID 来排序的），每一个数据页中的页号和最小主键构成主键目录。 索引页+数据页组成的组成的B+树就是聚簇索引。聚簇索引是 MySQL 基于主键索引结构创建的。 模拟 MySQL 的查找过程，首先从最顶层的索引页开始查找，查找 id&#x3D;37，因此定位到了索引页16，然后到索引页 16 中继续查找，此时同样能够定位到 id&#x3D;37 在索引页 3 中，然后继续查找，最终能够定位到数据实在数据页 8 中，加入数据页中8的结构如下： 完整的数据表： 3. 非主键索引假如现在对name+age(非主键)建立索引，那此时是存放的呢？此时 MySQL 根据会 name+age 维护一个单独的 B+ 树结构，数据依旧是存放在数据页中的，只不过是原来数据中的每条记录写的是 id&#x3D;xx，现在写的是name&#x3D;xx，age&#x3D;xx，id&#x3D;xx，不管怎么样，主键肯定会存放的。 在插入数据的时候，MySQL 首先会根据 name 进行排序，如果 name 一样，就根据联合索引中的 age 去排序，如果还一样，那么就会根据 主键 字段去排序。插入的原理就是这样子的。 假设现在要根据 name 查找到该条记录，且查询的字段（即 select 后面的查询字段）也仅仅有 name（只要是在 name,age,id 这三个字段中都可以）这个时候是能够直接获取到最终的记录的。 但如果查找的sql语句如下： 1SELECT * FROM student WHERE name=&#x27;wx&#x27; 那这下子就完蛋了，因为现在虽然根据 name 很快的定位到了该条记录，但是因为 name+age 不是聚簇索引，此时的 B+ 树的数据页中存放的仅仅是自己关联的索引和主键索引字段，并不会存其他的字段，所以这个时候其他的属性值是获取不到的，这时候该怎么办？ 这种情况下，MySQL 就需要进行回表查询了。此时 MySQL 就会根据定位到的某条记录中的 id 再次进行聚簇索引查找，也就是说会根据 id 去维护 id 的 B+ 树中查找。因为聚簇索引中数据页记录的是一条记录的完整的记录，这个过程就叫回表。 回表的含义：根据非主键索引查询到的结果并没有查找的字段值，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找到的记录才是完成的。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://mrqytalk.github.io/tags/Mysql/"}]},{"title":"银行家算法","slug":"银行家算法","date":"2022-04-16T12:20:20.000Z","updated":"2022-04-16T13:40:44.418Z","comments":false,"path":"2022/04/16/银行家算法/","link":"","permalink":"https://mrqytalk.github.io/2022/04/16/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/","excerpt":"","text":"1. 银行家算法概念1.1 介绍银行家算法（Banker’s Algorithm）是一个避免操作系统死锁（Deadlock）的著名算法，属于事先预防策略。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。 死锁：当两个以上的运算单元，双方都在等待对方停止执行，以获取系统资源，但是没有一方提前退出时，就称为死锁。 产生死锁必须同时满足以下四个条件： 禁止抢占（no preemption）：系统资源不能被强制从一个进程中退出。 持有和等待（hold and wait）：一个进程可以在等待时持有系统资源。 互斥（mutual exclusion）：资源只能同时分配给一个行程，无法多个行程共享。 循环等待（circular waiting）：一系列进程互相持有其他进程所需要的资源。 因此，预防死锁需要打破其中一项。 1.2 概括当一个进程申请使用资源的时候，银行家算法通过先 试探 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若判断结果为安全，则给该进程分配资源，若不安全则试探分配作废，让该进程阻塞。 安全系列不唯一，但只要存在一个就是安全策略，一定不会发生死锁 2. 银行家算法具体实现2.1 术语概念available:可用资源向量，记录系统中各类资源的当前可利用数目 allocation:记录每个进程中对各类资源当前的占有量 max:记录每个进程对各类资源的最大需求量 need: 记录每个进程中对各类资源当前的需求量，等于max-allocation request: 请求向量，记录某个进程当前对各类资源的申请量，是银行家算法的入口参数。 2.2 过程2.2.1 先决条件过程 request[i,j]&lt;need[i,j]，否则进程出错 request[i,j]&lt;available[i,j]，否认进程阻塞 2.2.2 试探分配过程 系统试着把资源分配给进程P，并对相应数据结构作如下修改： available[i,j] -request[i,j] allocation[i,j]+request[i,j] need[i,j]-request[i,j] 系统执行安全性检测子算法，以判断试分配后系统状态是否安全； 若第4步返回逻辑真值，即“安全”，则完成本次分配，返回； 否则，撤销此次（即第3步中的）试分配，进程P阻塞。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://mrqytalk.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://mrqytalk.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"操作系统","slug":"操作系统","permalink":"https://mrqytalk.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"操作系统","slug":"操作系统","permalink":"https://mrqytalk.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://mrqytalk.github.io/tags/Mysql/"},{"name":"算法","slug":"算法","permalink":"https://mrqytalk.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"操作系统","slug":"操作系统","permalink":"https://mrqytalk.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}