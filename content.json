{"meta":{"title":"mrqyTalk","subtitle":"","description":"","author":"喝水艺术家","url":"https://mrqytalk.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-04-14T03:13:06.822Z","updated":"2022-04-14T03:13:06.822Z","comments":false,"path":"about/index.html","permalink":"https://mrqytalk.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2022-04-14T03:13:06.823Z","updated":"2022-04-14T03:13:06.823Z","comments":false,"path":"books/index.html","permalink":"https://mrqytalk.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-16T12:25:45.369Z","updated":"2022-04-16T00:08:36.553Z","comments":false,"path":"categories/index.html","permalink":"https://mrqytalk.github.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-04-14T03:13:06.820Z","updated":"2022-04-14T03:13:06.820Z","comments":false,"path":"/404.html","permalink":"https://mrqytalk.github.io/404.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-04-14T03:13:06.826Z","updated":"2022-04-14T03:13:06.826Z","comments":false,"path":"repository/index.html","permalink":"https://mrqytalk.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-04-17T06:24:55.940Z","updated":"2022-04-17T06:24:55.940Z","comments":false,"path":"links/index.html","permalink":"https://mrqytalk.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-16T00:36:54.461Z","updated":"2022-04-16T00:36:54.461Z","comments":false,"path":"tags/index.html","permalink":"https://mrqytalk.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"二叉树基础","slug":"二叉树基础","date":"2022-06-18T07:49:10.000Z","updated":"2022-06-18T07:51:22.187Z","comments":true,"path":"2022/06/18/二叉树基础/","link":"","permalink":"https://mrqytalk.github.io/2022/06/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1. 二叉树1.1 概念二叉树（Binary tree）是树形结构的一个重要类型，二叉树特点是每个节点最多只能有两棵子树，且有左右之分，称为左子树和右子树。 1.2 二叉树的基本形态 空二叉树 只有一个根节点的二叉树 只有左子树 只有右子树 完全二叉树 1.3 二叉树的性质 二叉树的第i层上至多有2i-1个节点 深度为h的二叉树中至多含有2h-1个节点 若在任意一棵二叉树中，有n0个叶子节点，有n2个度为2的节点，则必有n0&#x3D;n2+1 具有n个节点的满二叉树深为log2n+1 1.3 二叉树的特殊类型 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。 ![preview](D:&#x2F;program x64&#x2F;Hexo&#x2F;source&#x2F;image&#x2F;view) 完全二叉树：完全二叉树是由满二叉树而引出来的，对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 ![&#x2F;img&#x2F;bVcTHUc](D:&#x2F;program x64&#x2F;Hexo&#x2F;source&#x2F;image&#x2F;bVcTHUc) 堆总是一个完全二叉树 2. 堆2.1 概念任意节点的值总是大于（小于）子节点的值 如果任意节点的值总是大于子节点的值，称为：最大堆、大顶堆 如果任意节点的值总是小于子节点的值，称为：最小堆、小顶堆 2.2 堆的性质 下标为i的节点的父节点下标：（i-1）/2【整数除法】 下标为i的节点的左孩子下标：i*2+1 下标为i的节点的右孩子下标：i*2+2","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://mrqytalk.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"冒泡排序、简单选择排序和插入排序","slug":"冒泡排序、简单选择排序和插入排序","date":"2022-06-18T07:28:14.000Z","updated":"2022-06-18T07:41:26.427Z","comments":false,"path":"2022/06/18/冒泡排序、简单选择排序和插入排序/","link":"","permalink":"https://mrqytalk.github.io/2022/06/18/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"1. 冒泡排序1.1 算法步骤（一）比较相邻的元素。如果第一个比第二个大，就交换他们两个 （二）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 （三）针对所有的元素重复以上的步骤，除了最后一个。 （四）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 1.2 算法分析平均时间复杂度: T(n) = O(n²)最坏时间复杂度:T(n) = O(n²)：当输入的数据是反序时，（此种情况下，可以for循环反序输出）最好时间复杂度:T(n) = O(n)：当输入的数据已经有序时，只需遍历一遍用于确认数据已有序。空间复杂度:O(1) 1.3 代码实现123456789101112131415161718192021222324252627public class BubbleSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // boolean flag = true不放在这里，因为放在这里优化的是初始数组就有序，放在下面则可以表示某次循环有序 for (int i = 1; i &lt; arr.length; i++) &#123; // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 此种优化只对有序数组起到作用，而如果是无序数组，这种优化还会增加负担，具体由代码第10行、18行、21行引起。 1234567891011121314151617181920212223242526272829import java.util.Arrays;/** * @author by 慕容琴羽 * @Date 2022/4/29 13:56 */public class suanfa &#123; public Integer[] bubbleSort(Integer[] array) &#123; for (int end = array.length-1; end &gt;0 ; end--) &#123; // sortIndex在数组完全有序的时候，完全有序时会将1赋值给end，end--后程序为0会退出 int sortIndex=1; for (int begin = 0; begin &lt;end; begin++) &#123; if (array[begin]&gt;array[begin+1])&#123; Integer temp=array[begin+1]; array[begin+1]=array[begin]; array[begin]=temp; sortIndex=begin;//记录每次交换的顺序，如果后面的数组有序，则这是最后一次交换的位置 &#125; &#125; end=sortIndex;//将最后一次的交换位置赋值给end，则再扫描的时候不需要再对后面有序数组扫描 &#125; return array; &#125; public static void main(String[] args) &#123; Integer[] array = &#123;1,2,3&#125;; System.out.println(Arrays.toString(new suanfa().bubbleSort(array))); &#125;&#125; 2. 简单选择排序2.1 算法步骤（一）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 （二）再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 （三）重复第二步，直到所有元素均排序完毕。 1.2 复杂度分析 选择排序是时间复杂度表现最稳定的排序算法之一，无论什么数据进去都是O(n²) 的时间复杂度…..所以用到它的时候，数据规模越小越好。 平均时间复杂度: T(n) = O(n²)最坏时间复杂度: T(n) = O(n²)最好时间复杂度: T(n) = O(n²)空间复杂度: O(1) 1.3 代码实现1234567891011121314151617181920212223242526272829public class SelectionSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 总共要经过 N-1 轮比较,剩最后一个的时候不用再比啦 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 记录目前能找到的最小值元素的下标 minIndex = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != minIndex) &#123; int tmp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = tmp; &#125; &#125; return arr; &#125;&#125; 3. 插入排序插入排序的原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 3.1 算法步骤（一）将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 （二）从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 3.2 算法复杂度平均时间复杂度: T(n) = O(n²)**最坏时间复杂度: T(n) = O(n²)**：输入数组按降序排列（完全逆序）**最好时间复杂度: T(n) = O(n)**：输入数组按升序排列（基本有序）空间复杂度: O(1) 3.3 代码实现12345678910111213141516171819202122232425public class InsertSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; arr.length; i++) &#123; // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; arr[j] = tmp; &#125; &#125; return arr; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://mrqytalk.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://mrqytalk.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Object划分","slug":"Object划分","date":"2022-04-24T09:03:33.000Z","updated":"2022-04-24T09:48:42.638Z","comments":false,"path":"2022/04/24/Object划分/","link":"","permalink":"https://mrqytalk.github.io/2022/04/24/Object%E5%88%92%E5%88%86/","excerpt":"","text":"1.PO(persistant object)持久对象PO 就是对应数据库中某个表中的一条记录，多个记录可以用 PO 的集合。 PO 中应该不包含任何对数据库的操作。 2.DO（Domain Object）领域对象就是从现实世界中抽象出来的有形或无形的业务实体。 3.TO(Transfer Object) ，数据传输对象不同的应用程序之间传输的对象 。 4.DTO（Data Transfer Object）数据传输对象这个概念来源于 J2EE 的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，泛指用于展示层与服务层之间的数据传输对象。 5.VO(value object) 值对象通常用于业务层之间的数据传递，和 PO 一样也是仅仅包含数据而已。但应是抽象出的业务对象 , 可以和表对应 , 也可以不 , 这根据业务的需要 。用 new 关键字创建，由GC 回收的。 View object：视图对象； 接受页面传递来的数据，封装对象 ；将业务处理完成的对象，封装成页面要用的数据。 6.BO(business object) 业务对象从业务模型的角度看 , 见 UML 元件领域模型中的领域对象。封装业务逻辑的java 对象 , 通过调用 DAO 方法 , 结合PO,VO 进行业务操作。 business object: 业务对象主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经历对应一个 PO ，社会关系对应一个 PO 。建立一个对应简历的 BO 对象处理简历，每个BO包含这些 PO 。这样处理业务逻辑时，我们就可以针对 BO 去处理。 7.POJO(plain ordinary java object) 简单无规则 java 对象传统意义的 java 对象。就是说在一些 Object&#x2F;Relation Mapping 工具中，能够做到维护数据库表记录的 persisent object 完全是一个符合 Java Bean 规范的纯 Java 对象，没有增加别的属性和方法。我的理解就是最基本的 java Bean ，只有属性字段及 setter 和 getter方法！POJO 是 DO&#x2F;DTO&#x2F;BO&#x2F;VO 的统称。 8.DAO(data access object) 数据访问对象是一个 sun 的一个标准 j2ee 设计模式，这个模式中有个接口就是 DAO ，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和 PO 结合使用， DAO 中包含了各种数据库的操作方法。通过它的方法 , 结合 PO 对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO， 提供数据库的 CRUD 操作。","categories":[{"name":"Java","slug":"Java","permalink":"https://mrqytalk.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://mrqytalk.github.io/tags/Java/"}]},{"title":"JVM之类加载机制","slug":"JVM之类加载机制","date":"2022-04-23T00:14:22.000Z","updated":"2022-04-23T00:15:07.673Z","comments":false,"path":"2022/04/23/JVM之类加载机制/","link":"","permalink":"https://mrqytalk.github.io/2022/04/23/JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","excerpt":"","text":"1. 类的生命周期其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，*而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)*。 另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 2. 类加载的过程2.1 加载加载阶段虚拟机完成的三件事： 通过一个类的全限定名来获取其定义的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 相对于类加载的其他阶段而言，加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 加载阶段完成后，虚拟机外部的进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。 加载.class文件的方式: 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件 2.2 连接2.2.1 验证: 确保被加载的类的正确性验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作: 文件格式验证: 验证字节流是否符合Class文件格式的规范；例如: 是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证: 对字节码描述的信息进行语义分析(注意: 对比javac编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了java.lang.Object之外。 字节码验证: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证: 确保解析动作能正确执行。 2.2.2 准备: 为类的静态变量分配内存，并将其初始化为默认值准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意: 这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 这里所设置的初始值通常情况下是数据类型默认的零值(如0、0L、null、false等)，而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为: public static int value = 3；那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的put static指令是在程序编译后，存放于类构造器&lt;clinit&gt;()方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的空值，即null。 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。假设上面的类变量value被定义为: public static final int value = 3；编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中 2.2.3 解析：把类中的符号引用转换为直接引用解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 2.3初始化初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式: 声明类变量是指定初始值 使用静态代码块为类变量指定初始值 2.3.1 JVM初始化步骤 假如这个类还没有被加载和连接，则程序先加载并连接该类 假如该类的直接父类还没有被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 2.3.2 类初始化时机只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种: 创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射(如Class.forName(“com.pdai.jvm.Test”)) 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类 2.4 使用类访问方法区内的数据结构的接口， 对象是Heap区的数据。 2.5 卸载Java虚拟机将结束生命周期的几种情况： 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 3.类加载器类加载器的层次： 注意: 这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。 站在Java开发人员的角度来看，类加载器可以大致划分为以下三类 : 启动类加载器: Bootstrap ClassLoader，负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载)。*启动类加载器是无法被Java程序直接引用的。 扩展类加载器: Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。 应用程序类加载器: Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点: 在执行非置信代码之前，自动验证数字签名。 动态地创建符合用户特定需要的定制化构建类。 从特定的场所取得java class，例如数据库中和网络中。 类加载的三种方式： 1、命令行启动应用时候由JVM初始化加载 2、通过Class.forName()方法动态加载 3、通过ClassLoader.loadClass()方法动态加载 注意： Class.forName(): 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块； ClassLoader.loadClass(): 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。 Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 4. JVM类加载机制全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 双亲委派机制, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 4.1 双亲委派机制过程（一）当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 （二）当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 （三）如果BootStrapClassLoader加载失败(例如在$JAVA_HOME&#x2F;jre&#x2F;lib里未查找到该class)，会使用ExtClassLoader来尝试加载； （四）若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。 双亲委派优势 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行","categories":[{"name":"Java","slug":"Java","permalink":"https://mrqytalk.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://mrqytalk.github.io/tags/JVM/"}]},{"title":"MySql存储引擎","slug":"MySql存储引擎","date":"2022-04-19T07:03:42.000Z","updated":"2022-04-19T07:07:40.740Z","comments":false,"path":"2022/04/19/MySql存储引擎/","link":"","permalink":"https://mrqytalk.github.io/2022/04/19/MySql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","excerpt":"","text":"1. 存储引擎的相关命令 查看mysql提供什么存储引擎并格式化输出：show engines \\G; 查看默认的存储引擎：show variables like &#39;%storage_engine%&#39;; 修改默认的存储引擎 如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：SET DEFAULT_STORAGE_ENGINE=MyISAM; 或者修改 my.cnf 文件： 123default-storage-engine=MyISAM # 重启服务systemctl restart mysqld.service 创建表时指定存储引擎： 1CREATE TABLE 表名(建表语句;) ENGINE = 存储引擎名称; 修改表的存储引擎： 1ALTER TABLE 表名 ENGINE = 存储引擎名称; 2. 存储引擎介绍2.1 InnoDB引擎 MySQL大于等于5.5之后，默认采用InnoDB引擎 。 具备外键支持功能的事务存储引擎 InnoDB是MySQL的默认事务型引擎 ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。 除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。 除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。 InnoDB是为处理巨大数据量的最大性能设计 。 对比MyISAM的存储引擎， InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和索引。 MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较高 ，而且内存大小对性能有决定性的影响。 2.2 MyISAM和InnoDB的比较 对比项 MyISAM InnoDB 外键 不支持 支持 事务 不支持 支持 行表锁 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作 缓存 只缓存索引，不缓存真实数据 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 自带系统表使用 Y N 关注点 性能：节省资源、消耗少、简单业务 事务：并发写、事务、更大资源 默认安装 Y N 默认使用 N Y 2.3 InnoDB表的优势InnoDB存储引擎在实际应用中拥有诸多优势，比如操作便利、提高了数据库的性能、维护成本低等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB崩溃恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。 InnoDB存储引擎在主内存中维护缓冲池，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。 在专用服务器上，物理内存中高达80%的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃，在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。 InnoDB不仅支持当前读写，也会缓冲改变的数据到数据流磁盘 。 InnoDB的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高查询的速度。使用InnoDB可以压缩表和相关的索引，可以 在不影响性能和可用性的情况下创建或删除索引 。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。通过查询INFORMATION_SCHEMA库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。 当处理大数据量时，InnoDB兼顾CPU，以达到最大性能 。 2.4 InnoDB架构1. 缓冲池 缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。 2. 更改缓存 更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分InnoDB缓冲池。在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由innodb_change_buffering配置项管理。 3. 自适应哈希索引 自适应哈希索引将负载和足够的内存结合起来，使得InnoDB像内存数据库一样运行，不需要降低事务上的性能或可靠性。这个特性通过innodb_adaptive_hash_index选项配置，或者通过– skip-innodb_adaptive_hash_index命令行在服务启动时关闭。 4. 重做日志缓存 重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过innodb_log_buffer_size配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存使得大型事务能够正常运行而不需要写入磁盘。 5. 系统表空间 系统表空间包括InnoDB数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引数据。多表共享，系统表空间被视为共享表空间。 6. 双写缓存 双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存后，InnoDB才会将数据页写入合适的位置。 7. 撤销日志 撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这些片段包含于回滚片段中。 8. 每个表一个文件的表空间 每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中，而不是系统表空间中。这个功能通过innodb_file_per_table配置项开启。每个表空间由一个单独的.ibd数据文件代表，该文件默认被创建在数据库目录中。 9. 通用表空间 使用CREATE TABLESPACE语法创建共享的InnoDB表空间。通用表空间可以创建在MySQL数据目录之外能够管理多个表并支持所有行格式的表。 10. 撤销表空间 撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由innodb_undo_tablespaces配置项配置。 11. 临时表空间 用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。innodb_temp_data_file_path配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在innodb_data_home_dir变量指定的目录下创建一个自动扩展的数据文件。 12. 重做日志 重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间，重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自动在初始化期间重新进行。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://mrqytalk.github.io/tags/MySql/"}]},{"title":"MySql索引","slug":"MySql索引","date":"2022-04-18T14:48:34.000Z","updated":"2022-04-18T14:53:37.445Z","comments":false,"path":"2022/04/18/MySql索引/","link":"","permalink":"https://mrqytalk.github.io/2022/04/18/MySql%E7%B4%A2%E5%BC%95/","excerpt":"","text":"1. Mysql索引简介1.1 索引概念索引是一个单独的、存储在磁盘上的、排好序数据库结构，它们包含着对数据表里所有记录的引用指针。使用索引的功能在于快速找出在某个或多个列中有一特定值的行。 1.2 索引的分类按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引按物理存储分类可分为：聚簇索引、二级索引按字段特性分类可分为：主键索引、普通索引、前缀索引按字段个数分类可分为：单列索引、联合索引 注：MySQL的索引类型由存储引擎决定，Mysql5.1之前的默认引擎是MyISAM，之后版本是InnoDB。而InnoDB你支持hash索引，但自适应Hash索引，即：InnoDB中Hash索引的创建由存储引擎引擎自动优化创建，不能人为干预是否为表创建Hash索引。因为hash索引只能精确匹配（如select * from user where name &#x3D; xx），不支持范围查找。 2. B+树2.1 B+树的特点 在 B+ 树中，所有数据记录节点都是按照键值的大小存放在同一层的叶子节点上，而非叶子结点只存储key的信息，这样可以大大减少每个节点的存储的key的数量，降低B+ 树的高度 B+ 树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。 B+ 树的层级更少：相较于 B 树， B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快 B+ 树查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定; B+ 树天然具备排序功能：B+ 树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。 B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。 2.2 B+树的结构图 Mysql存储的时候以数据页为最小单位，数据页与数据页之间通过双向链表关联，数据与数据页之间通过单项链表关联。 数据页中的数据是按照主键排序（没有主键是由 MySQL自己维护的 ROW_ID 来排序的），每一个数据页中的页号和最小主键构成主键目录。 索引页+数据页组成的组成的B+树就是聚簇索引。聚簇索引是 MySQL 基于主键索引结构创建的。 模拟 MySQL 的查找过程，首先从最顶层的索引页开始查找，查找 id&#x3D;37，因此定位到了索引页16，然后到索引页 16 中继续查找，此时同样能够定位到 id&#x3D;37 在索引页 3 中，然后继续查找，最终能够定位到数据实在数据页 8 中，加入数据页中8的结构如下： 完整的数据表： 3. 非主键索引假如现在对name+age(非主键)建立索引，那此时是存放的呢？此时 MySQL 根据会 name+age 维护一个单独的 B+ 树结构，数据依旧是存放在数据页中的，只不过是原来数据中的每条记录写的是 id&#x3D;xx，现在写的是name&#x3D;xx，age&#x3D;xx，id&#x3D;xx，不管怎么样，主键肯定会存放的。 在插入数据的时候，MySQL 首先会根据 name 进行排序，如果 name 一样，就根据联合索引中的 age 去排序，如果还一样，那么就会根据 主键 字段去排序。插入的原理就是这样子的。 假设现在要根据 name 查找到该条记录，且查询的字段（即 select 后面的查询字段）也仅仅有 name（只要是在 name,age,id 这三个字段中都可以）这个时候是能够直接获取到最终的记录的。 但如果查找的sql语句如下： 1SELECT * FROM student WHERE name=&#x27;wx&#x27; 那这下子就完蛋了，因为现在虽然根据 name 很快的定位到了该条记录，但是因为 name+age 不是聚簇索引，此时的 B+ 树的数据页中存放的仅仅是自己关联的索引和主键索引字段，并不会存其他的字段，所以这个时候其他的属性值是获取不到的，这时候该怎么办？ 这种情况下，MySQL 就需要进行回表查询了。此时 MySQL 就会根据定位到的某条记录中的 id 再次进行聚簇索引查找，也就是说会根据 id 去维护 id 的 B+ 树中查找。因为聚簇索引中数据页记录的是一条记录的完整的记录，这个过程就叫回表。 回表的含义：根据非主键索引查询到的结果并没有查找的字段值，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找到的记录才是完成的。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://mrqytalk.github.io/tags/MySql/"}]},{"title":"JVM之类字节码详解","slug":"JVM之类字节码详解","date":"2022-04-18T14:44:59.000Z","updated":"2022-04-18T14:46:57.630Z","comments":false,"path":"2022/04/18/JVM之类字节码详解/","link":"","permalink":"https://mrqytalk.github.io/2022/04/18/JVM%E4%B9%8B%E7%B1%BB%E5%AD%97%E8%8A%82%E7%A0%81%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"1. 类字节码结构 本文参考Java全栈知识体系所作笔记，图片版权归作者所有。 1.1 多语言编译为字节码在JVM运行计算机是不能直接运行java代码的，必须要先运行java虚拟机，再由java虚拟机运行编译后的java代码。 为什么jvm不能直接运行java代码呢，这是因为在cpu层面看来计算机中所有的操作都是一个个指令的运行汇集而成的，java是高级语言，只有人类才能理解其逻辑，计算机是无法识别的，所以java代码必须要先编译成字节码文件，jvm才能正确识别代码转换后的指令并将其运行。 Java代码间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的JVM虚拟机去读取执行，从而实现一次编写，到处运行的目的。 JVM也不再只支持Java，由此衍生出了许多基于JVM的编程语言，如Groovy, Scala, Koltin等等。 1.2 Java字节码文件class文件(即字节码文件)本质上是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中。jvm根据其特定的规则解析该二进制数据，从而得到相关信息。 Class文件采用一种伪结构来存储数据，它有两种类型：无符号数和表。 1.3 Class文件的结构属性字节码文件包含以下类型的数据： 魔数： 在代码中出现但没有解释的数字常量或字符串，又称魔法值，在代码开发中应该尽量避免。 大多数情况下，我们都是通过扩展名来识别一个文件的类型的，但是扩展名是可以修改的，当一个文件的扩展名被修改过，识别一个文件的类型就必须使用“魔数”。很多类型的文件，其起始的几个字节的内容是固定的（或是有意填充，或是本就如此）这几个字节的内容也被称为魔数，因为根据这几个字节的内容就可以确定文件类型。 2. 字节码实现2.1 编译文件以下面的例子为例： 123456789//Main.javapublic class Main &#123; private int m; public int inc() &#123; return m + 1; &#125;&#125; 1javac Main.java //通过Javac命令进行编译 以文本形式打开生成的class文件： 123456789101112131415161718cafe babe 0000 0034 0013 0a00 0400 0f090003 0010 0700 1107 0012 0100 016d 01000149 0100 063c 696e 6974 3e01 0003 28295601 0004 436f 6465 0100 0f4c 696e 654e756d 6265 7254 6162 6c65 0100 0369 6e630100 0328 2949 0100 0a53 6f75 7263 6546696c 6501 0009 4d61 696e 2e6a 6176 610c0007 0008 0c00 0500 0601 0010 636f 6d2f7268 7974 686d 372f 4d61 696e 0100 106a6176 612f 6c61 6e67 2f4f 626a 6563 74002100 0300 0400 0000 0100 0200 0500 06000000 0200 0100 0700 0800 0100 0900 00001d00 0100 0100 0000 052a b700 01b1 00000001 000a 0000 0006 0001 0000 0003 0001000b 000c 0001 0009 0000 001f 0002 00010000 0007 2ab4 0002 0460 ac00 0000 01000a00 0000 0600 0100 0000 0800 0100 0d000000 0200 0e 文件开头的4个字节(“cafe babe”)称之为 魔数，唯有以”cafe babe”开头的class文件方可被虚拟机所接受，这4个字节就是字节码文件的身份识别。 0000是编译器jdk版本的次版本号0，0034转化为十进制是52,是主版本号，java的版本号从45开始，除1.0和1.1都是使用45.x外,以后每升一个大版本，版本号加一。也就是说，编译生成该class文件的jdk版本为1.8.0。 2.2 反编译字节码文件 使用到java内置的一个反编译工具javap可以反编译字节码文件, 用法: javap &lt;options&gt; &lt;classes&gt; 其中，&lt;options&gt;选项包括： 1234567891011121314151617-help --help -? 输出此用法消息-version 版本信息-v -verbose 输出附加信息-l 输出行号和本地变量表-public 仅显示公共类和成员-protected 显示受保护的/公共类和成员-package 显示程序包/受保护的/公共类 和成员 (默认)-p -private 显示所有类和成员-c 对代码进行反汇编-s 输出内部类型签名-sysinfo 显示正在处理的类的 系统信息 (路径, 大小, 日期, MD5 散列)-constants 显示最终常量-classpath &lt;path&gt; 指定查找用户类文件的位置-cp &lt;path&gt; 指定查找用户类文件的位置-bootclasspath &lt;path&gt; 覆盖引导类文件的位置 输入命令javap -verbose -p Main.class查看输出内容: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class //Class文件当前所在位置， Last modified 2018-4-7; size 362 bytes //最后修改时间，文件大小 MD5 checksum 4aed8540b098992663b7ba08c65312de //MD5值 Compiled from &quot;Main.java&quot; //编译文件来源 public class com.rhythm7.Main //类的全限定 minor version: 0 //jdk次版本号， major version: 52 //主版本号 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #4.#18 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #3.#19 // com/rhythm7/Main.m:I #3 = Class #20 // com/rhythm7/Main #4 = Class #21 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/rhythm7/Main; #14 = Utf8 inc #15 = Utf8 ()I #16 = Utf8 SourceFile #17 = Utf8 Main.java #18 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #19 = NameAndType #5:#6 // m:I #20 = Utf8 com/rhythm7/Main #21 = Utf8 java/lang/Object&#123; private int m; descriptor: I flags: ACC_PRIVATE public com.rhythm7.Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/rhythm7/Main; public int inc(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 8: 0 LocalVariableTable: Start Length Slot Name Signature 0 7 0 this Lcom/rhythm7/Main;&#125;SourceFile: &quot;Main.java&quot; 开头的7行信息包括:Class文件当前所在位置，最后修改时间，文件大小，MD5值，编译自哪个文件，类的全限定名，jdk次版本号，主版本号。 然后紧接着的是该类的访问标志：ACC_PUBLIC, ACC_SUPER，访问标志的含义如下: 标志名称 标志值 含义 ACC_PUBLIC 0x0001 是否为Public类型 ACC_FINAL 0x0010 是否被声明为final，只有类可以设置 ACC_SUPER 0x0020 是否允许使用invokespecial字节码指令的新语义 ACC_INTERFACE 0x0200 标志这是一个接口 ACC_ABSTRACT 0x0400 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 ACC_SYNTHETIC 0x1000 标志这个类并非由用户代码产生 ACC_ANNOTATION 0x2000 标志这是一个注解 ACC_ENUM 0x4000 标志这是一个枚举 2.3 常量池(Constant pool）常量池主要存放的是两大类常量： 字面量(Literal) 符号引用(Symbolic References) 类和接口的全限定名(Fully Qualified Name) 字段的名称和描述符号(Descriptor) 方法的名称和描述符 123456#1 = Methodref #4.#18 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V#4 = Class #21 // java/lang/Object#7 = Utf8 &lt;init&gt;#8 = Utf8 ()V#18 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V#21 = Utf8 java/lang/Object 第一个常量是一个方法定义，指向了第4和第18个常量。以此类推查看第4和第18个常量。最后可以拼接成第一个常量右侧的注释内容: 1java/lang/Object.&quot;&lt;init&gt;&quot;:()V 这段可以理解为该类的实例构造器的声明，由于Main类没有重写构造方法，所以调用的是父类的构造方法。此处也说明了Main类的直接父类是Object。 该方法默认返回值是V, 也就是void，无返回值。 123456#2 = Fieldref #3.#19 // com/rhythm7/Main.m:I#3 = Class #20 // com/rhythm7/Main#5 = Utf8 m#6 = Utf8 I#19 = NameAndType #5:#6 // m:I#20 = Utf8 com/rhythm7/Main 此处声明了一个字段m，类型为I, I即是int类型。关于字节码的类型对应如下： 标识字符 含义 B 基本类型byte C 基本类型char D 基本类型double F 基本类型float I 基本类型int J 基本类型long S 基本类型short Z 基本类型boolean V 特殊类型void L 对象类型，以分号结尾，如Ljava&#x2F;lang&#x2F;Object; 对于数组类型，每一位使用一个前置的[字符来描述，如定义一个java.lang.String[][]类型的维数组，将被记录为[[Ljava/lang/String; 2.4 方法表集合在常量池之后的是对类内部的方法描述，在字节码中以表的集合形式表现，暂且不管字节码文件的16进制文件内容如何，我们直接看反编译后的内容。 123private int m; descriptor: I flags: ACC_PRIVATE 此处声明了一个私有变量m，类型为int，返回值为int 12345678910111213public com.rhythm7.Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/rhythm7/Main; 这里是构造方法：Main()，返回值为void, 公开方法。 code内的主要属性为： stack: 最大操作数栈，JVM运行时会根据这个值来分配栈帧(Frame)中的操作栈深度,此处为1 locals: 局部变量所需的存储空间，单位为Slot, Slot是虚拟机为局部变量分配内存时所使用的最小单位，为4个字节大小。方法参数(包括实例方法中的隐藏参数this)，显示异常处理器的参数(try catch中的catch块所定义的异常)，方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是，locals的大小并不一定等于所有局部变量所占的Slot之和，因为局部变量中的Slot是可以重用的。 args_size: 方法参数的个数，这里是1，因为每个实例方法都会有一个隐藏参数this。 attribute_info: 方法体内容，0,1,4为字节码”行号”，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的”java&#x2F;lang&#x2F;Object.”“:()V, 然后执行返回语句，结束方法。 LineNumberTable: 该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。可以使用 -g:none 或-g:lines选项来取消或要求生成这项信息，如果选择不生成LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。 LocalVariableTable: 该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是arg0, arg1这样的占位符。 start 表示该局部变量在哪一行开始可见，length表示可见行数，Slot代表所在帧栈位置，Name是变量名称，然后是类型签名。","categories":[{"name":"Java","slug":"Java","permalink":"https://mrqytalk.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://mrqytalk.github.io/tags/JVM/"}]},{"title":"MySql逻辑架构","slug":"MySql逻辑架构","date":"2022-04-18T08:01:36.000Z","updated":"2022-04-18T14:53:25.208Z","comments":false,"path":"2022/04/18/MySql逻辑架构/","link":"","permalink":"https://mrqytalk.github.io/2022/04/18/MySql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/","excerpt":"","text":"1. Mysql逻辑架构剖析1.1 服务器处理客户端请求 以查询请求为案例，服务端对客户端的请求处理如下： 1.2 第一层：连接层系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。 用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行 用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限 TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。 1.3 第二层：服务层 SQL Interface: SQL接口 接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口 Parser: 解析器 在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。 词法分析：你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。 语法分析：语法分析器（比如：Bison）会根据语法规则，判断你输 入的这个 SQL 语句是否 满足 MySQL 语法 。 在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树 ，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。 Optimizer: 查询优化器 SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划 。 这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。 它使用选取-投影-连接策略进行查询。例如： 1select * from student where gender =&#x27;女&#x27; 这个SELECT查询先根据WHERE语句进行选取 ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性投影 ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 连接起来生成最终查询结果。 Caches &amp; Buffers： 查询缓存组件 MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 这个查询缓存可以在不同客户端之间共享 。 从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。 1.4 第三层：引擎层插件式存储引擎层（Storage Engines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。 MySQL8默认支持以下的存储引擎如下： 1.5 第四层：存储层所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。 2. 数据库缓冲池（buffer pool）InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请占用内存来作为数据缓冲池 ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。 这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行 I/O 的时间 。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。 2.1 缓冲池VS查询缓存缓冲池：在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，包括：数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。 查询缓存：是提前把查询结果缓存 起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。 2.2 缓冲池如何读取数据缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。 2.3 查看&#x2F;设置缓冲池的大小查看： 1show variables like &#x27;innodb_buffer_pool_size&#x27;; 缓冲池的value值以bit为单位 修改： 1set global innodb_buffer_pool_size = 268435456;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://mrqytalk.github.io/tags/MySql/"}]},{"title":"银行家算法","slug":"银行家算法","date":"2022-04-16T12:20:20.000Z","updated":"2022-04-16T13:40:44.418Z","comments":false,"path":"2022/04/16/银行家算法/","link":"","permalink":"https://mrqytalk.github.io/2022/04/16/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/","excerpt":"","text":"1. 银行家算法概念1.1 介绍银行家算法（Banker’s Algorithm）是一个避免操作系统死锁（Deadlock）的著名算法，属于事先预防策略。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。 死锁：当两个以上的运算单元，双方都在等待对方停止执行，以获取系统资源，但是没有一方提前退出时，就称为死锁。 产生死锁必须同时满足以下四个条件： 禁止抢占（no preemption）：系统资源不能被强制从一个进程中退出。 持有和等待（hold and wait）：一个进程可以在等待时持有系统资源。 互斥（mutual exclusion）：资源只能同时分配给一个行程，无法多个行程共享。 循环等待（circular waiting）：一系列进程互相持有其他进程所需要的资源。 因此，预防死锁需要打破其中一项。 1.2 概括当一个进程申请使用资源的时候，银行家算法通过先 试探 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若判断结果为安全，则给该进程分配资源，若不安全则试探分配作废，让该进程阻塞。 安全系列不唯一，但只要存在一个就是安全策略，一定不会发生死锁 2. 银行家算法具体实现2.1 术语概念available:可用资源向量，记录系统中各类资源的当前可利用数目 allocation:记录每个进程中对各类资源当前的占有量 max:记录每个进程对各类资源的最大需求量 need: 记录每个进程中对各类资源当前的需求量，等于max-allocation request: 请求向量，记录某个进程当前对各类资源的申请量，是银行家算法的入口参数。 2.2 过程2.2.1 先决条件过程 request[i,j]&lt;need[i,j]，否则进程出错 request[i,j]&lt;available[i,j]，否认进程阻塞 2.2.2 试探分配过程 系统试着把资源分配给进程P，并对相应数据结构作如下修改： available[i,j] -request[i,j] allocation[i,j]+request[i,j] need[i,j]-request[i,j] 系统执行安全性检测子算法，以判断试分配后系统状态是否安全； 若第4步返回逻辑真值，即“安全”，则完成本次分配，返回； 否则，撤销此次（即第3步中的）试分配，进程P阻塞。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://mrqytalk.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://mrqytalk.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"操作系统","slug":"操作系统","permalink":"https://mrqytalk.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://mrqytalk.github.io/categories/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://mrqytalk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"操作系统","slug":"操作系统","permalink":"https://mrqytalk.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://mrqytalk.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://mrqytalk.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://mrqytalk.github.io/tags/JVM/"},{"name":"MySql","slug":"MySql","permalink":"https://mrqytalk.github.io/tags/MySql/"},{"name":"操作系统","slug":"操作系统","permalink":"https://mrqytalk.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}